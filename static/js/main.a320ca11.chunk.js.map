{"version":3,"sources":["components/CardComponent.module.css","components/MainHeader.module.css","state/action-types/characterSRSactionTypes.ts","state/action-creators/characterSRSactionCreator.ts","state/action-types/previousCharactersActionTypes.ts","state/action-creators/previousCharactersActionCreator.ts","state/action-types/cardDisplayTypes.ts","state/action-creators/cardDisplayActionCreator.ts","state/reducers/characterSRSreducer.ts","state/reducers/previousCharactersReducer.ts","state/reducers/cardDisplayReducers.ts","state/reducers/index.ts","state/store.ts","applogic/characterSRSlogic/calculateCharacterSRSorder/calculateContentReviewPriority.ts","applogic/characterSRSlogic/calculateCharacterSRSorder/calculateCharacterSRSorder.ts","applogic/characterSRSlogic/calculateCharacterSRSorder/characterSRSlogicBoundary.ts","applogic/FlashcardDisplayLogic/FlashCardStateManipulation.ts","applogic/flashcardHelperFunctions/gettingFlashCards.ts","components/ScrollableTextAreaComponent.tsx","components/EditableTextAreaComponent.tsx","components/CardComponent.tsx","interfaces/types/sortingValue.ts","applogic/FlashcardDisplayLogic/FlashCardFiltering.ts","pages/Practice.tsx","components/DisplayTagItem.tsx","components/DisplayTags.tsx","pages/Tags.tsx","components/FileInputMainDeck.tsx","pages/LoadAndSave.tsx","applogic/pageHelpers/createDeckHelper.ts","pages/EditDeck.tsx","components/CardListComponent.tsx","components/TagFilteringComponent.tsx","components/TagFilteringComponentList.tsx","pages/SearchFlashcards.tsx","pages/Statistics.tsx","interfaces/types/createDeckValues.ts","applogic/pageHelpers/mergeDeckHelper.ts","components/FileInputMergeFiles.tsx","config/routes.ts","pages/Home.tsx","pages/CreateDeck.tsx","applogic/createDeck/createDeckMain.ts","pages/MergeFiles.tsx","pages/Settings.tsx","applogic/flashcardHelperFunctions/settingsHelper.ts","components/MainHeader.jsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["module","exports","CharacterSRSactionTypes","createSRSobject","characterSRSobject","dispatch","type","CREATESRSOBJECT","payload","CharactersSRS","Tags","Map","Content","cardNumber","cardName","frontSide","backSide","primaryInfo","secondaryInfo","notableCards","dateOfLastReview","repetitionValue","repetitionHistory","tags","addNewTag","updatedtags","ADDNEWTAG","cards","editSingleTag","NewTag","OldTagTitle","EDITSINGLETAG","removeTag","REMOVETAG","editListItem","listItem","EDITLISTITEM","editListItemInBulk","listItemsInBulk","EDITLISTITEMINBULK","createDeck","newCards","CREATENEWDECK","addNewCardsToDeck","ADDNEWCARDSTODECK","deleteOrEditCardOrder","toDelete","toChange","deck","DELETEOREDITCARDORDER","CharsToBeDeleted","OrderToBeChanged","replacesettings_filtercardsbytag","settingsToReplace","REPLACESETTINGS_FILTERCARDSBYTAG","SettingsToReplace","PreviousCharactersActionTypes","addToPreviousCharacters","newItem","existingState","ADDTOPREVIOUSCHARACTERS","newContent","substractFromPreviousCharacters","SUBSTRACTFROMPREVIOUSCHARACTERS","CardDisplayTypes","cardDisplayChangeState","newState","CHANGESTATE","content","initialState","deckName","deckInfo","settings","insertCardsInDeck","characterList","doInsertCardsInDeck","sort","c1","c2","remainingCards","length","head","tail","updatedCharacterList","flashCard","largestCardNumber","map","each","updatedFlashCard","cardnumber","_objectSpread","adjustCardNumber","result","doAddSingleCardToList","addSingleCardToList","updatedList","savedCard","updateNotableCards","push","savedCard2","newFlashcard","doUpdateNotableCard","updatedNotableCards","privateEditSingleTagAndCreateNewDeck","characterSRSObject","cleanTitle","privateCleanTagTitle","newTag","updatedCardTagList","privateUpdateTagListOnDeck","updatetedFlashCardList","privateUpdateFlashCardList","oldCards","oldTagTitle","newCardList","Array","forEach","eachCard","oldTitleInList","eachTagIndex","updatedCard","privateUpdateTagListOnEachCard","newCardTagList","eachTag","deckTagList","tagsMinusEditedTag","key","currentValue","input","replace","trim","charsToBeDeletedRange","isNaN","splitBySpace","split","num1","num2","Number","isInteger","from","v","k","validateCharsToBeDeleted","orderToBeChangedTuple","validateOrderToBeChanged","deleteCards","resEdit","cardToDelete","newCardNumber","cardNumToDelete","rawaddedCards","addedCardsWithUpdatedNotable","i","rawaddedDeck","editCardOrder","allNums","numsToSetToNums","Set","firstnum","lastnum","validInput","filter","indexOf","cardsWithoutDeleted","newNums","updatedCards","oldToNew","value","Object","entries","oldCard","updatedOld_notableCards","replaceNotable","newNumberOnCard","e","newNum","updateCardListAfterDeleted","keys","characterSRSreducer","state","arguments","undefined","action","updatedTags","newContentNumber","index","earlyIndexMembers","slice","lateIndexMembers","newContentList","editListItemsInBulk","newContentInBulk","allNewNumbers","redoneArray","includes","concat","addNewCardToDeck","settingsToUpdate","previousCharactersReducer","exixtingState","showPrimaryCardInfo","showSecondaryCardInfo","readAloud","changeStateReducer","reducers","combineReducers","cardDisplay","cardDisplayReducers","characterSRS","previousCharacters","store","createStore","applyMiddleware","thunk","calculateReviewPriority","splitIntoReviewNumbers","eachByReview","splitIntoHistoryValues","eachByHistory","splitIntoDateStrings","eachByDate","splitIntoRandomSorted","flat","contentThatCanBePracticed","item","n1","n2","eachNumber","getSumOfHistory","history","reduce","sum","current","eachDate","isCorrectDateString","Date","toISOString","substr","eachDateString","seed","sumOfReviewNumbers","a","b","getSeedFromFlashCards","randomSortedNumbers","array","t","m","Math","floor","random","shuffle","x","sin","dateString","doCalculateNextCharacter","tenMostRecent","getMostRecentlyPracticed","reviewPrioritySorted","getReviewPriority","allContentItems","forbiddenCharacters","forbiddenCharacterNumbers","eachContent","nonProhibited","currentContent","mostRecentContentObjects","notEnoughCharacters","maxLengthInteger","recentlyPracticed","calculateNextCharacter","parseNumberListInput","numberlist","editNumberValue","htmlelement","defaultValue","textvalue","currentTarget","textContent","parseInt","editStringvalue","editNumberList","rawValue","toString","join","editTagList","mustBeIn","stringList","parseStringListInput","onlyLegitimateTextValues","elem","self","getCardSimpleDisplayInfo","currentState","cardExistInDeck","card","getFlashCard","cardCandidates","mapkeys","ScrollableTextArea","_ref","text","_jsx","style","width","height","overflowY","readOnly","EditableTextArea","showCard","showArea","info","onInputChange","textareaRef","useRef","adjustTextareaHeight","newHeight","scrollHeight","useEffect","ref","onChange","event","minHeight","resize","CardComponent","props","showData","show","alwaysShow","useDispatch","bindActionCreators","characterSRSactionCreators","characterSRSstate","useSelector","cardToDisplay","setCardToDisplay","useState","showNotableChardButtons","setShowNotableChardButtons","tagToDisplay","setTagToDisplay","showTagButtons","setShowTagButtons","tempPrimaryInfo","setTempPrimaryInfo","handlePrimaryInfoInputChange","target","tempSecondaryInfo","setTempSecondaryInfo","handleSecondaryInfoInputChange","tempReviewValue","tempDateOfLastReview","tempKeyword","tempNotableCards","tempCardName","tempTagsOnCard","renderFrontSide","ordinaryFrontSide","_jsxs","children","onInput","FlashCardStateManipulation","contentEditable","audioFrontSide","displayAudioFieldWhenBacksideIsShown","withAudio","id","className","classes","audioText","displayAudioFieldWhenFrontsideIsShown","generateListOfCardButtons","currentCard","localCard","localList","onClick","generateListOfTagButtons","setTagTextFunction","tagName","saveEdit","changesMade","newContentObject","valueOf","displayNotableCardButtons","displayTagButtons","displayTag","getTagFromDeck","tagdata","document","getElementById","focus","select","console","log","selectText","newCard","characterListElement","infoStringToDisplay","displayOriginalCharacter","displayCard","SortingValueAll","isSortingValue","getSettings_filtercardsbytag","filterByTags","dogetSettings_filtercardsbytag","subcategoryname","subcategory","inp","localTagsFilter","cardsToUse","calculateFilter","allNumbersFromRecord","stringsToHandle","num","str","updatedCardsLists","handleFilterString","secureCardNum","uncertainNum","resultSet","values","eachstr","secureCardList","uncertainCardList","newSecure","newUncertain","tagAndType","tag","filterLogic","cardsWithRelevantTag","hasTag","_flashCard$tags","Practice","addCharactersReference","_addCharactersReferen","previousCard","showCharacterSRSContentElement","setShowCharacterSRSContentElement","showPreviusCard","setShowPreviusCard","addMoreCharactersTextField","setAddMoreCharactersTextField","previousCharactersActionCreators","previousCharactersState","cardDisplayActionCreator","cardDisplayLocalState","localTagsFilterNumbers","getSettings_filtercardsbytag_numbers","generateCardComponent","showSRSContent","addOrRemoveCardsToPractice","charactersToAdd","addCards","charsToAdd","getNewFinalCharValue","sortedCharactersLowestToHighest","sortetReverse","deleteANumberOfCharacters","charactersYouWantToAdd","charactersToDelete","addANumberOfCharacters","numberli","parseNumberList","newCharactersToBeAdded","addOrRemoveCardsToPracticeFromList","isFinite","changeOnNewCharacterInputField","handleKeyDown","spaceOrRightArrow","increaseReviewValueWithOne","setShowCharacterSRSContentElementFunc","decreaseReviewValueWithOne","increaseReviewValueWithFive","respondToAPresentedCharacterSRSObject","decreaseReviewValueWithFive","increaseOrDecreaseReviewValue","updatedDate","updatedReviewValue","updatedContent","generateRepetitionHistoryOfLength30","updatedCharacterSRS","oldHistory","increaseOrDecrease","basicHistory","removeLast","displayMostRecentCharacters","listToDisplay","mostRecentCharacter","resultString","reverse","netRepetition","buttonsToEditRecentChars","increaseRepetitionOfLastCharacterByOne","displayMostRecentCard","reduceRepetitionOfLastCharacterByOne","toggleShowPreviousCard","editRepetitionOfLastCharacterByOne","integerToAdd","mostRecentCharactersList","recentCharNumber","recentChar","recentCharReviewnumberReduced","updatedChar","desiredCard","getMostRecentCard","recentNumber","cardDeck","changeShowPrimaryInformationValue","updatedValue","changeShowSecondaryInformationValue","changeReadAloud","displayNumberOfCharacters","finalCharValue","allCharacters","size","onKeyDown","placeholder","autoComplete","buttonsToShowAndHandleCharacterSRSContentElement","buttonsToReturn","todoPageContent","contentOrNotEnough","filteredCards","has","srslogic","srscalculationResult","newChar","updatedPrevius","previuscharacterLocalUpdate","showPreviusCharacter","localpreviusCard","localshowPreviusCard","mostRecentCard","DisplayTagItem","tempTagTitle","TagItem","tempTagBody","cleanTagTitle","overlapWithOtherTags","previousTagKeys","eachKeyIndex","eachKey","detectOverlapWithOtherTags","DisplayTags","getNestedArray","tagMap","nestedElems","allkeys","allvalues","temparray","sortNestedArrayTagsByTitleAlphabeticly","nestedArrayTagsToDosplay","setNestedArrayTagsToDosplay","currentTagListToDisplay","tagSubstringSearchField","setTagSubstringSearchField","sortAllCharsAlphabetically","resultArray","displayByChosenTitle","stringToLookFor","eachTags","toLowerCase","eachMap","tagTitle","tagBody","displayTagsBoolean","setDisplayTagsBoolean","fname","setFname","addToTagList","currentDecktags","typeMap","mykeys","myvalues","toggleDisplayTags","localRemoveTag","relevantvalue","newKeys","newValues","deckState","showState","displayTags","FileInputMainDeck","onContentChange","files","setFiles","setContent","FilePond","oninit","handleInit","allowMultiple","acceptedFileTypes","onaddfile","error","fileItem","file","reader","FileReader","onload","_e$target","readAsText","onupdatefiles","fileItems","LoadAndSave","saveAsJsonfile","filename","element","createElement","setAttribute","encodeURIComponent","display","body","appendChild","click","removeChild","getCharactersJson","url","fetch","then","res","json","data","JSON","stringify","fileContent","testLarge","parse","downloadCharacterSRSobject","stringToListSplitBySpace","arrayToCard","numberOfCards","numberRange","notable","ea","stringToNumbersSplitBySpace","replaceDeckNameAndInfo","inputDeck","newname","newinfo","allcards","allTags","oldname","currentcard","curretTagList","currentTag","updateCardTags","newtags","oldTagNames","oldTagName","oldTagValue","updatedvalue","updateTagList","generateAllLinesDeck","rawText","remainingRawText","lookForNewLine","previousLineIsCurly","lineIsCurly","currentStr","currentDeck","currentChar","charAt","nextChar","doGenerateCards","generateCards","numbercard","tagsfromcards","name","restag","updatedWithNums","examp","EditDeck","localdeckName","setLocaldeckName","localdeckInfo","setLocaldeckInfo","localdeleteCards","setLocaldeleteCards","localeditCards","setLocaleditCards","localcardNumber","setLocalcardNumber","localcardName","setLocalcardName","localfrontSide","setLocalfrontSide","localbackSide","setLocalbackSide","localprimaryInfo","setLocalprimaryInfo","localsecondaryInfo","setLocalsecondaryInfo","localnotableCards","setLocalnotableCards","localtags","setLocaltags","generateTags","deckTags","accumulator","handleCardNumberChange","newStr","deleteCardsOnChange","editCardsOnChange","updatedDeck","changeDeckNameAndInfo","deleteInput","editInput","editAndDeleteCardsButtonFunc","addFormInputToDeck","CardListComponent","TagFilteringComponent","suggestionsTagName","setSuggestionsTagName","suggestionsFilterValue","setSuggestionsFilterValue","setTagName","filterValue","setFilterValue","saveTagFilteringState","listToUpdate","newValue","valueToTest","toUpperCase","newName","nameToTest","setFunction","handleNewFilteringValue","AutoSuggest","suggestions","onSuggestionsClearRequested","onSuggestionsFetchRequested","language","startsWith","getSuggestionsTagName","onSuggestionSelected","_","_ref2","suggestionValue","getSuggestionValue","suggestion","renderSuggestion","inputProps","_ref3","method","highlightFirstSuggestion","_ref4","_ref5","_ref6","removeTagFilteringComponent","allKeys","currentK","mystr","updatedRecord","newnum","eachValue","TagFilteringComponentList","setShow","doSetShow","contentList","eachVal","addElement","largestElement","mynum","currentRecord","setfunction","clear","showFitler","displayIfShow","stringValues","displayIfNotShow","SearchFlashcards","allTagKeys","allCards","setLocalTagsFilter","shouldRerender","setShouldRerender","cardNumAfterFiltering","setCardNumAfterFiltering","displayChars","setDisplayChars","maxCardsToDisplay","setMaxCardsToDisplay","numberIntervalFilter","setNumberIntervalFilter","tagSubstringFilter","setTagSubstringFilter","fontSideSubstring","setFontSideSubstring","backSideSubstring","setBackSideSubstring","filterCards","inputListOfCards","displayByInterval","displayByChosenTagTitleSubstring","displayByFrontSideOfCard","displayByBackSideOfCard","removeUnknown","substringIsFound","eachArrayKey","sortedByNumber","sortedByReviewValue","sortedByLastReviewDate","sortedByHistorySum","htmlFor","Statistics","setFilteredCards","countCardNumbers","allNumbers","largestNum","allOfThese","eachNum","reviewNumbersCount","generateCountingDisplay","countedNumbers","countFilteredCardNumbers","currentLine","newReviewNumbers","oldReviewNumber","numberToAdd","doResetHistory","doResetDate","today","yesterday","setDate","getDate","reduceByOne","eachRepetitionNumber","newRepetitionNumber","resetHistory","resetDates","CardOrder","InputTextType","WritingSystem","getHashCode","hash","charCodeAt","FileInputMergeFiles","handleContent","flashCardDecks","setFlashCardDecks","pond","React","updateDeckState","flatDeck","myMap","readAndParseFile","Promise","resolve","reject","onloadend","_event$target","readyState","DONE","strToParse","String","onerror","removeAllFiles","getFiles","removeFile","async","hashCodeOfDeck","set","onremovefile","deckToChange","oldValue","get","oldIndexNumber","labelIdle","routes","path","component","exact","selectsLanguage","setSelectsLanguage","SIMPLIFIED","sortorder","setsortorder","CHRONOLOGICAL","textType","setTextType","RAWTEXT","outputs","setOutputs","download","isVocab","fileextension","dict","Blob","href","URL","createObjectURL","handleVocab","endpint","vocab","isEmptyString","bodyDict","headers","Headers","append","options","response","handleDownload","GENERIC","ORDEREDLINESALL","resultOfCardGeneration","required","rows","TRADITIONAL","FREQUENCY","ORDEREDLINESTWO","localfiltercardsbytag","setLocalfiltercardsbytag","MainHeader","header","route","NavLink","activeClassName","active","to","App","Switch","Route","render","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","Provider","BrowserRouter"],"mappings":"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","file":"static/js/main.a320ca11.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"characterListElement\":\"CardComponent_characterListElement__2CLsf\",\"audioText\":\"CardComponent_audioText__u1X_D\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"header\":\"MainHeader_header__C49QC\",\"active\":\"MainHeader_active__1qQII\"};","export enum CharacterSRSactionTypes{\r\n    CREATESRSOBJECT = \"createsrsobject\",\r\n    EDITLISTITEM = \"editlistitem\",\r\n    EDITLISTITEMINBULK = \"editlistiteminbult\",\r\n    ADDNEWCARDSTODECK = \"addnewcardstodeck\",\r\n    ADDNEWTAG = \"addnewtag\",\r\n    REMOVETAG = \"removetag\",\r\n    EDITSINGLETAG = \"editsingletag\",\r\n    CREATENEWDECK = \"createnewdeck\",\r\n    DELETEOREDITCARDORDER = \"deleteoreditcardorder\",\r\n    REPLACESETTINGS_FILTERCARDSBYTAG = \"replacesettings_filtercardsbytag\"\r\n}","import {FlashCard} from \"../../interfaces/flashcard\";\r\nimport {FlashCardDeck} from \"../../interfaces/flashcarddeck\";\r\nimport {Dispatch} from \"redux\";\r\nimport {CharacterSRSaction} from \"../actions/characterSRSactions\";\r\nimport {CharacterSRSactionTypes} from \"../action-types/characterSRSactionTypes\";\r\nexport const createSRSobject = (characterSRSobject: FlashCardDeck) => {\r\n    return (dispatch: Dispatch<CharacterSRSaction>) => {\r\n        dispatch({\r\n            type: CharacterSRSactionTypes.CREATESRSOBJECT,\r\n            payload: {\r\n                CharactersSRS: characterSRSobject,\r\n                Tags: new Map(),\r\n                Content: [{\r\n                    cardNumber: 0,\r\n                    cardName: \"\",\r\n                    frontSide: \"\",\r\n                    backSide: \"\",\r\n                    primaryInfo: \"\",\r\n                    secondaryInfo: \"\",\r\n                    notableCards: [],\r\n                    dateOfLastReview: \"\",\r\n                    repetitionValue: 0,\r\n                    repetitionHistory: [],\r\n                    tags: []\r\n                }]\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nexport const addNewTag = (updatedtags: Record<string, string>, characterSRSobject: FlashCardDeck) => {\r\n    return (dispatch: Dispatch<CharacterSRSaction>) => {\r\n        dispatch({\r\n            type: CharacterSRSactionTypes.ADDNEWTAG,\r\n            payload: {\r\n                CharactersSRS: characterSRSobject,\r\n                Tags: updatedtags,\r\n                Content: characterSRSobject.cards\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nexport const editSingleTag = (NewTag: string[], OldTagTitle: string, CharactersSRS: FlashCardDeck) => {\r\n    return (dispatch: Dispatch<CharacterSRSaction>) => {\r\n        dispatch({\r\n            type: CharacterSRSactionTypes.EDITSINGLETAG,\r\n            payload: {\r\n                NewTag: NewTag,\r\n                OldTagTitle: OldTagTitle,\r\n                CharactersSRS: CharactersSRS\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nexport const removeTag = (updatedtags: Record<string, string>, characterSRSobject: FlashCardDeck) => {\r\n    return (dispatch: Dispatch<CharacterSRSaction>) => {\r\n        dispatch({\r\n            type: CharacterSRSactionTypes.REMOVETAG,\r\n            payload: {\r\n                CharactersSRS: characterSRSobject,\r\n                Tags: updatedtags,\r\n                Content: characterSRSobject.cards\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\n\r\nexport const editListItem = (listItem: FlashCard, characterSRSobject: FlashCardDeck) => {\r\n    return (dispatch: Dispatch<CharacterSRSaction>) => {\r\n        dispatch({\r\n            type: CharacterSRSactionTypes.EDITLISTITEM,\r\n            payload: {\r\n                CharactersSRS: characterSRSobject,\r\n                Content: [listItem]\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nexport const editListItemInBulk = (listItemsInBulk: FlashCard[], characterSRSobject: FlashCardDeck) => {\r\n    return (dispatch: Dispatch<CharacterSRSaction>) => {\r\n        dispatch({\r\n            type: CharacterSRSactionTypes.EDITLISTITEMINBULK,\r\n            payload: {\r\n                CharactersSRS: characterSRSobject,\r\n                Content: listItemsInBulk\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nexport const createDeck = (newCards: FlashCard[], characterSRSobject: FlashCardDeck) => {\r\n    return (dispatch: Dispatch<CharacterSRSaction>) => {\r\n        dispatch({\r\n            type: CharacterSRSactionTypes.CREATENEWDECK,\r\n            payload: {\r\n                CharactersSRS: characterSRSobject,\r\n                Content: newCards\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nexport const addNewCardsToDeck = (newCards: FlashCard[], characterSRSobject: FlashCardDeck) => {\r\n    return (dispatch: Dispatch<CharacterSRSaction>) => {\r\n        dispatch({\r\n            type: CharacterSRSactionTypes.ADDNEWCARDSTODECK,\r\n            payload: {\r\n                CharactersSRS: characterSRSobject,\r\n                Content: newCards\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nexport const deleteOrEditCardOrder = (toDelete: string, toChange: string, deck: FlashCardDeck) => {\r\n    return (dispatch: Dispatch<CharacterSRSaction>) => {\r\n        dispatch({\r\n            type: CharacterSRSactionTypes.DELETEOREDITCARDORDER,\r\n            payload: {\r\n                CharactersSRS: deck,\r\n                CharsToBeDeleted: toDelete,\r\n                OrderToBeChanged: toChange\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nexport const replacesettings_filtercardsbytag = (settingsToReplace: Record<string, string>, deck: FlashCardDeck) => {\r\n    return (dispatch: Dispatch<CharacterSRSaction>) => {\r\n        dispatch({\r\n            type: CharacterSRSactionTypes.REPLACESETTINGS_FILTERCARDSBYTAG,\r\n            payload: {\r\n                CharactersSRS: deck,\r\n                SettingsToReplace: settingsToReplace\r\n            }\r\n        })\r\n    }\r\n}\r\n","\r\nexport enum PreviousCharactersActionTypes {\r\n    ADDTOPREVIOUSCHARACTERS = \"addtopreviouscharacters\",\r\n    SUBSTRACTFROMPREVIOUSCHARACTERS = 'substractfrompreviouscharacters'\r\n}","\r\nimport {FlashCard} from \"../../interfaces/flashcard\";\r\nimport {PreviousCharactersActionTypes} from \"../action-types/previousCharactersActionTypes\";\r\nimport {PreviousCharacterAction} from \"../actions/previousCharactersAction\";\r\nimport {Dispatch} from \"redux\";\r\n\r\nexport const addToPreviousCharacters = (newItem: FlashCard, existingState: [FlashCard[], FlashCard[], FlashCard[]]) => {\r\n    return (dispatch: Dispatch<PreviousCharacterAction>) => {\r\n        dispatch({\r\n            type: PreviousCharactersActionTypes.ADDTOPREVIOUSCHARACTERS,\r\n            payload: {\r\n                Content: existingState,\r\n                newContent: newItem\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nexport const substractFromPreviousCharacters = (newItem: FlashCard, existingState: [FlashCard[], FlashCard[], FlashCard[]]) => {\r\n    return (dispatch: Dispatch<PreviousCharacterAction>) => {\r\n        dispatch({\r\n            type: PreviousCharactersActionTypes.SUBSTRACTFROMPREVIOUSCHARACTERS,\r\n            payload: {\r\n                Content: existingState,\r\n                newContent: newItem\r\n            }\r\n        })\r\n    }\r\n}","export enum CardDisplayTypes {\r\n    CHANGESTATE = \"changestate\"\r\n}","import {Dispatch} from \"redux\";\r\nimport {CardDisplayAction} from \"../actions/cardDisplayAction\";\r\nimport {CardDisplayTypes} from \"../action-types/cardDisplayTypes\";\r\nimport CardDisplay from \"../../interfaces/cardDisplay\";\r\n\r\nexport const cardDisplayChangeState = (newState: CardDisplay, existingState: CardDisplay) => {\r\n    return (dispatch: Dispatch<CardDisplayAction>) => {\r\n        dispatch({\r\n            type: CardDisplayTypes.CHANGESTATE,\r\n            payload: {\r\n                content: existingState,\r\n                newContent: newState\r\n            }\r\n        })\r\n    }\r\n}","import {CharacterSRSaction} from \"../actions/characterSRSactions\";\r\nimport {CharacterSRSactionTypes} from \"../action-types/characterSRSactionTypes\";\r\nimport {FlashCard} from \"../../interfaces/flashcard\";\r\nimport {FlashCardDeck} from \"../../interfaces/flashcarddeck\"\r\nimport {addNewCardsToDeck} from \"../action-creators/characterSRSactionCreator\";\r\n\r\nconst initialState: FlashCardDeck = {\r\n    deckName: '',\r\n    deckInfo: '',\r\n    settings: {} as Record<string, Record<string, string>>,\r\n    tags: {} as Record<string, string>,\r\n    cards: []\r\n}\r\n\r\nconst editListItem = (newContent: FlashCard, characterSRSObject: FlashCardDeck): FlashCardDeck => {\r\n    const characterList: FlashCard[] = characterSRSObject.cards\r\n    const newContentNumber: number = newContent.cardNumber\r\n    const index = characterList.map(function(e) { return e.cardNumber; }).indexOf(newContentNumber);\r\n\r\n    const earlyIndexMembers: FlashCard[] = characterList.slice(0, index);\r\n    const lateIndexMembers: FlashCard[] = characterList.slice(index+1, characterList.length)\r\n\r\n    const newContentList: FlashCard[] = earlyIndexMembers\r\n    newContentList.push(newContent)\r\n    newContentList.push(...lateIndexMembers)\r\n\r\n    const result: FlashCardDeck = {\r\n        ...characterSRSObject,\r\n        deckName: characterSRSObject.deckName,\r\n        cards: newContentList\r\n    }\r\n    return result\r\n}\r\n\r\nconst editListItemsInBulk = (newContentInBulk: FlashCard[], characterSRSObject: FlashCardDeck): FlashCardDeck => {\r\n    const allNewNumbers: number[] = newContentInBulk.map(each => each.cardNumber)\r\n    const characterList: FlashCard[] = characterSRSObject.cards.filter(each => !allNewNumbers.includes(each.cardNumber))\r\n    const redoneArray: FlashCard[] = characterList.concat(newContentInBulk)\r\n    const result: FlashCardDeck = {\r\n        ...characterSRSObject,\r\n        deckName: characterSRSObject.deckName,\r\n        cards: redoneArray\r\n    }\r\n    return result\r\n}\r\n\r\nconst createDeck = (newContentInBulk: FlashCard[], characterSRSObject: FlashCardDeck): FlashCardDeck => {\r\n    const result: FlashCardDeck = {\r\n        ...characterSRSObject,\r\n        cards: newContentInBulk\r\n    }\r\n    return result\r\n}\r\n\r\nexport const addNewCardToDeck = (newCards: FlashCard[], characterSRSObject: FlashCardDeck): FlashCardDeck => {\r\n    const characterList: FlashCard[] = characterSRSObject.cards\r\n    const redoneArray: FlashCard[] = insertCardsInDeck(newCards, characterList)\r\n    const result: FlashCardDeck = {\r\n        ...characterSRSObject,\r\n        deckName: characterSRSObject.deckName,\r\n        cards: redoneArray\r\n    }\r\n    return result\r\n}\r\n\r\nfunction insertCardsInDeck(newCards: FlashCard[], characterList: FlashCard[]): FlashCard[] {\r\n    const sortedNewCards = newCards.sort((c1, c2) => c1.cardNumber - c2.cardNumber)\r\n    const sortedCharacterList = characterList.sort((c1, c2) => c1.cardNumber - c2.cardNumber)\r\n    const res: FlashCard[] = doInsertCardsInDeck(sortedNewCards, sortedCharacterList)\r\n    return res\r\n}\r\n\r\nfunction doInsertCardsInDeck(remainingCards: FlashCard[], characterList: FlashCard[]): FlashCard[] {\r\n    if (remainingCards.length == 0) {\r\n        return characterList\r\n    }else {\r\n        const [head, ...tail] = remainingCards;\r\n        const updatedCharacterList = addSingleCardToList(head, characterList)\r\n        const sortedCards = updatedCharacterList.sort((c1, c2) => c1.cardNumber - c2.cardNumber)\r\n        return doInsertCardsInDeck(tail, sortedCards)\r\n    }\r\n}\r\n\r\nfunction addSingleCardToList(flashCard: FlashCard, characterList: FlashCard[]): FlashCard[] {\r\n    const largestCardNumber: number = characterList.map(each => each.cardNumber).sort()[characterList.length-1]\r\n    const updatedFlashCard: FlashCard = adjustCardNumber(flashCard, largestCardNumber)\r\n    const result: FlashCard[] = doAddSingleCardToList(updatedFlashCard, updatedFlashCard.cardNumber, [], characterList)\r\n    return result;\r\n}\r\n\r\nfunction adjustCardNumber(flashCard: FlashCard, largestCardNumber: number): FlashCard {\r\n    const cardnumber = flashCard.cardNumber\r\n    if (cardnumber < 1 || cardnumber > largestCardNumber) {\r\n        const newCard: FlashCard = {...flashCard, cardNumber: largestCardNumber + 1}\r\n        return newCard\r\n    } else {\r\n        return flashCard\r\n    }\r\n}\r\n\r\nfunction doAddSingleCardToList(flashCard: FlashCard, cardNumber: number, updatedList: FlashCard[], characterList: FlashCard[]): FlashCard[] {\r\n    if (characterList.length == 0 && updatedList.length == 0) {\r\n        return [flashCard]\r\n    } else if (characterList.length == 0) {\r\n        const lastNewElem: FlashCard = updatedList[updatedList.length - 1]\r\n        if (lastNewElem.cardNumber < cardNumber) {\r\n            const savedCard = updateNotableCards(flashCard, cardNumber)\r\n            updatedList.push(savedCard)\r\n            return updatedList\r\n        } else {\r\n            return updatedList\r\n        }\r\n    } else if(characterList[0].cardNumber > cardNumber) {\r\n        //increment the cardnumber\r\n        const [head, ...tail] = characterList;\r\n        //newCard: FlashCard = {...eachCard, repetitionValue: newRepetitionNumber}\r\n        const newFlashcard: FlashCard = {...head, cardNumber: head.cardNumber + 1}\r\n        const savedCard = updateNotableCards(newFlashcard, cardNumber)\r\n        updatedList.push(savedCard)\r\n        return doAddSingleCardToList(flashCard, cardNumber, updatedList, tail)\r\n    } else if (characterList[0].cardNumber == cardNumber) {\r\n        const savedCard = updateNotableCards(flashCard, cardNumber)\r\n        updatedList.push(savedCard)\r\n        const [head, ...tail] = characterList;\r\n        const newFlashcard: FlashCard = {...head, cardNumber: head.cardNumber + 1}\r\n        const savedCard2 = updateNotableCards(newFlashcard, cardNumber)\r\n        updatedList.push(savedCard2)\r\n        return doAddSingleCardToList(flashCard, cardNumber, updatedList, tail)\r\n    } else {\r\n        const [head, ...tail] = characterList;\r\n        const savedCard = updateNotableCards(head, cardNumber)\r\n        updatedList.push(savedCard)\r\n        return doAddSingleCardToList(flashCard, cardNumber, updatedList, tail)\r\n    }\r\n}\r\n\r\nfunction updateNotableCards(newFlashcard: FlashCard, cardNumber: number): FlashCard {\r\n    const notableCards: number[] = newFlashcard.notableCards\r\n    const result: FlashCard = doUpdateNotableCard(newFlashcard, cardNumber, [], notableCards)\r\n    return result\r\n}\r\n\r\nfunction doUpdateNotableCard(newFlashcard: FlashCard, cardNumber: number, updatedNotableCards: number[], notableCards: number[]): FlashCard {\r\n    if (notableCards.length == 0) {\r\n        const updatedCard: FlashCard = {...newFlashcard, notableCards: updatedNotableCards}\r\n        return updatedCard\r\n    } else {\r\n        const [head, ...tail] = notableCards;\r\n        if (head < cardNumber) {\r\n            updatedNotableCards.push(head)\r\n            return doUpdateNotableCard(newFlashcard, cardNumber, updatedNotableCards, tail)\r\n        } else {\r\n            updatedNotableCards.push(head + 1)\r\n            return doUpdateNotableCard(newFlashcard, cardNumber, updatedNotableCards, tail)\r\n        }\r\n    }\r\n}\r\n\r\nconst addNewTag = (updatedTags: Record<string, string>, characterSRSObject: FlashCardDeck): FlashCardDeck => {\r\n    const result: FlashCardDeck = {\r\n        ...characterSRSObject,\r\n        tags: updatedTags\r\n    }\r\n    return result\r\n}\r\n\r\nconst removeTag = (updatedTags: Record<string, string>, characterSRSObject: FlashCardDeck): FlashCardDeck => {\r\n    const result: FlashCardDeck = {\r\n        ...characterSRSObject,\r\n        tags: updatedTags\r\n    }\r\n    return result\r\n}\r\n\r\nconst editSingleTag = (NewTag: string[], OldTagTitle: string, characterSRSObject: FlashCardDeck): FlashCardDeck => {\r\n    const result: FlashCardDeck = privateEditSingleTagAndCreateNewDeck(NewTag, OldTagTitle, characterSRSObject)\r\n    return result\r\n}\r\n\r\nconst privateEditSingleTagAndCreateNewDeck = (NewTag: string[], OldTagTitle: string, characterSRSObject: FlashCardDeck): FlashCardDeck => {\r\n    const cleanTitle: string = privateCleanTagTitle(NewTag[0])\r\n    const newTag: string[] = [cleanTitle, NewTag[1]]\r\n\r\n    if (cleanTitle.length > 0) {\r\n        const updatedCardTagList: Record<string, string> = privateUpdateTagListOnDeck(characterSRSObject.tags, newTag, OldTagTitle)\r\n        const updatetedFlashCardList: FlashCard[] = privateUpdateFlashCardList(characterSRSObject.cards, newTag, OldTagTitle)\r\n        var newDeck: FlashCardDeck = {...characterSRSObject, tags: updatedCardTagList, cards: updatetedFlashCardList}\r\n        return newDeck\r\n    }\r\n    return characterSRSObject\r\n}\r\n\r\nconst privateUpdateFlashCardList = (oldCards: FlashCard[], newTag: string[], oldTagTitle: string): FlashCard[] => {\r\n    var newCardList: FlashCard[] = new Array()\r\n    oldCards.forEach(function (eachCard) {\r\n        var oldTitleInList: boolean = false\r\n        for (let eachTagIndex in eachCard.tags) {\r\n            if (eachCard.tags[eachTagIndex] === oldTagTitle) {\r\n                oldTitleInList = true\r\n            }\r\n        }\r\n        if (oldTitleInList) {\r\n            const updatedCard: FlashCard = privateUpdateTagListOnEachCard(eachCard, newTag, oldTagTitle)\r\n            newCardList.push(updatedCard)\r\n        }else {\r\n            newCardList.push(eachCard)\r\n        }\r\n    });\r\n    return newCardList\r\n}\r\n\r\nconst privateUpdateTagListOnEachCard = (eachCard: FlashCard, newTag: string[], oldTagTitle: string) => {\r\n    var newCardTagList: string[] = new Array()\r\n    eachCard.tags.forEach(function (eachTag){\r\n        if (eachTag != oldTagTitle) {\r\n            newCardTagList.push(eachTag)\r\n        }\r\n    })\r\n    newCardTagList.push(newTag[0])\r\n    const newCard: FlashCard = {...eachCard, tags: newCardTagList}\r\n    return newCard;\r\n}\r\n\r\nconst privateUpdateTagListOnDeck = (deckTagList: Record<string, string>, newTag: string[], oldTagTitle: string): Record<string, string> => {\r\n    var tagsMinusEditedTag: Record<string, string> = {}\r\n    for (let key in deckTagList) {\r\n        if (key != oldTagTitle) {\r\n            const currentValue: string = deckTagList[key]\r\n            tagsMinusEditedTag[key] = currentValue\r\n        }\r\n    }\r\n    tagsMinusEditedTag[newTag[0]] = newTag[1]\r\n    return tagsMinusEditedTag\r\n}\r\n\r\nconst privateCleanTagTitle = (input: string): string => {\r\n    if (input) {\r\n        return input.replace(/ /g,'').replace(/,/g, \"\").trim();\r\n    }\r\n    return \"\"\r\n}\r\n\r\nexport function deleteOrEditCardOrder(CharsToBeDeleted: string, OrderToBeChanged: string, CharactersSRS: FlashCardDeck): FlashCardDeck {\r\n    const charsToBeDeletedRange: number[] = validateCharsToBeDeleted(CharsToBeDeleted)\r\n    const orderToBeChangedTuple: [number, number] = validateOrderToBeChanged(OrderToBeChanged)\r\n    if (OrderToBeChanged == \"\" && charsToBeDeletedRange.length > 0) {\r\n        const resDelete = deleteCards(charsToBeDeletedRange, CharactersSRS)\r\n        return resDelete\r\n    }else if (CharsToBeDeleted == \"\" && !isNaN(orderToBeChangedTuple[0]) && !isNaN(orderToBeChangedTuple[1])) {\r\n        const resEdit: FlashCardDeck = editCardOrder(orderToBeChangedTuple, CharactersSRS)\r\n        return resEdit\r\n    }else {\r\n        return CharactersSRS\r\n    }\r\n}\r\n\r\nexport function replacesettings_filtercardsbytag(SettingsToReplace: Record<string, string>, CharactersSRS: FlashCardDeck): FlashCardDeck {\r\n    var settingsToUpdate: Record<string, Record<string, string>> = CharactersSRS.settings\r\n    settingsToUpdate[\"filtercardsbytag\"] = SettingsToReplace\r\n    const updatedDeck: FlashCardDeck = {...CharactersSRS, settings: settingsToUpdate}\r\n    return updatedDeck\r\n}\r\n\r\nfunction deleteCards(input: number[], CharactersSRS: FlashCardDeck): FlashCardDeck {\r\n    if (input == null || input.length == 0) {\r\n        return CharactersSRS\r\n    }\r\n    const allNums: number[] = CharactersSRS.cards.map(each => each.cardNumber)\r\n    if (allNums.length == 0) {\r\n        return CharactersSRS\r\n    }\r\n    const numsToSetToNums: number[] = Array.from(new Set(allNums)).sort()\r\n    const firstnum: number = numsToSetToNums[0]\r\n    const lastnum: number = numsToSetToNums[numsToSetToNums.length-1]\r\n    if (firstnum != 1 || lastnum != numsToSetToNums.length || numsToSetToNums.length != allNums.length) {\r\n        return CharactersSRS\r\n    }\r\n\r\n    const validInput: number[] = input.filter(each => allNums.indexOf(each) > -1)\r\n    if (validInput.length == 0) {\r\n        return CharactersSRS\r\n    }\r\n\r\n    const cardsWithoutDeleted: FlashCard[] = CharactersSRS.cards.filter(each => validInput.indexOf(each.cardNumber) == -1)\r\n\r\n    const newNums: number[] = cardsWithoutDeleted.map(each => each.cardNumber)\r\n    const newRange: number[] = Array.from(Array(newNums.length).keys()).map(each => each + 1)\r\n    const oldToNew: [number, number][] = newRange.map(each => [newNums[each-1],each])\r\n\r\n    var updatedCards: FlashCard[] = updateCardListAfterDeleted(oldToNew, cardsWithoutDeleted)\r\n    const updatedDeck: FlashCardDeck = {...CharactersSRS, cards: updatedCards}\r\n    return updatedDeck;\r\n}\r\n\r\nfunction updateCardListAfterDeleted(oldToNew: [number, number][], cardsWithoutDeleted: FlashCard[]) {\r\n    var newCardList: FlashCard[] = []\r\n    const oldCardNums: number[] = cardsWithoutDeleted.map(each => each.cardNumber)\r\n    for (const [key, value] of Object.entries(cardsWithoutDeleted)) {\r\n        const oldCard: FlashCard = value\r\n        const updatedOld_notableCards: FlashCard = {...oldCard, notableCards: replaceNotable(oldToNew, oldCard.notableCards)}\r\n        const newNumberOnCard: number[] = oldToNew.filter(each => each[0] == updatedOld_notableCards.cardNumber).map(e => e[1])\r\n        if (newNumberOnCard.length == 0) {\r\n            newCardList.push(updatedOld_notableCards)\r\n        }else {\r\n            const newNum: number = newNumberOnCard[0]\r\n            const updatedCard: FlashCard = {...updatedOld_notableCards, cardNumber: newNum}\r\n            newCardList.push(updatedCard)\r\n        }\r\n    }\r\n    return newCardList;\r\n}\r\n\r\nfunction replaceNotable(oldToNew: [number, number][], notableCards: number[]): number[] {\r\n    const newCards: number[] = oldToNew.filter(each => notableCards.indexOf(each[0]) > -1).map(e => e[1])\r\n    return newCards\r\n}\r\n\r\nfunction editCardOrder(input: [number, number], CharactersSRS: FlashCardDeck): FlashCardDeck {\r\n    const cardToDelete: FlashCard = CharactersSRS.cards[input[0]-1]\r\n    var newCardNumber: number = 0\r\n    var cardNumToDelete: number = 0\r\n    if (input[1] > input[0]) {\r\n        newCardNumber = input[1] + 1\r\n        cardNumToDelete = input[0]\r\n    }else {\r\n        newCardNumber = input[1]\r\n        cardNumToDelete = input[0] + 1\r\n    }\r\n    const updatedCardToDelete: FlashCard = {...cardToDelete, cardNumber: newCardNumber}\r\n    const rawaddedCards: FlashCard[] = insertCardsInDeck([updatedCardToDelete], CharactersSRS.cards)\r\n    const addedCardsWithUpdatedNotable: FlashCard[] = rawaddedCards.map(each => updatedNotableCards(cardNumToDelete, newCardNumber, each))\r\n    const rawaddedDeck: FlashCardDeck = {...CharactersSRS, cards: addedCardsWithUpdatedNotable}\r\n\r\n    const deckWithMovedCardDeleted: FlashCardDeck = deleteCards([cardNumToDelete], rawaddedDeck)\r\n    return deckWithMovedCardDeleted\r\n}\r\n\r\nfunction updatedNotableCards(cardNumToDelete: number, newCardNumber: number, rawaddedCards: FlashCard) {\r\n    var newCards: number[] = []\r\n    const oldCards: number[] = rawaddedCards.notableCards\r\n    for (let i = 0; i < oldCards.length; i++) {\r\n        newCards.push(oldCards[i])\r\n        if (oldCards[i] == cardNumToDelete) {\r\n            newCards.push(newCardNumber)\r\n        }\r\n    }\r\n    const result: FlashCard = {...rawaddedCards, notableCards: newCards.sort()}\r\n    return result;\r\n}\r\n\r\nfunction validateCharsToBeDeleted(CharsToBeDeleted: string): number[] {\r\n    if (CharsToBeDeleted == null || CharsToBeDeleted == \"\") {\r\n        return []\r\n    }\r\n    if (!isNaN(+CharsToBeDeleted)) {\r\n        return [+CharsToBeDeleted]\r\n    }\r\n    const splitBySpace: string[] = CharsToBeDeleted.split(\"-\")\r\n    if (splitBySpace.length != 2 || isNaN(+splitBySpace[0]) || isNaN(+splitBySpace[1])) {\r\n        return []\r\n    }\r\n    const num1: number = +splitBySpace[0]\r\n    const num2: number = +splitBySpace[1]\r\n    if (!Number.isInteger(num1) || !Number.isInteger(num2)) {\r\n        return []\r\n    }\r\n    if (num1 > num2) {\r\n        return []\r\n    }else if (num1 == num2) {\r\n        return [num1]\r\n    }else {\r\n        const res: number[] = Array.from({length: ((num2+1) - num1)}, (v, k) => k + num1);\r\n        return res\r\n    }\r\n    return []\r\n}\r\n\r\nfunction validateOrderToBeChanged(OrderToBeChanged: string): [number, number] {\r\n    if (OrderToBeChanged == null || OrderToBeChanged == \"\") {\r\n        return [0, 0]\r\n    }\r\n    const splitBySpace: string[] = OrderToBeChanged.split(\",\")\r\n    if (splitBySpace.length != 2 || isNaN(+splitBySpace[0]) || isNaN(+splitBySpace[1])) {\r\n        return [0,0]\r\n    }\r\n    const num1: number = +splitBySpace[0]\r\n    const num2: number = +splitBySpace[1]\r\n    if (!Number.isInteger(num1) || !Number.isInteger(num2)) {\r\n        return [0,0]\r\n    }\r\n    if (num1 > num2) {\r\n        return [num1, num2]\r\n    }else if (num1 == num2) {\r\n        return [0,0]\r\n    }else {\r\n        return [num1, num2]\r\n    }\r\n    return [0,0]\r\n}\r\n\r\nconst characterSRSreducer = (state: FlashCardDeck = initialState, action: CharacterSRSaction): FlashCardDeck => {\r\n    switch (action.type) {\r\n        case CharacterSRSactionTypes.CREATESRSOBJECT:\r\n            return action.payload.CharactersSRS\r\n        case CharacterSRSactionTypes.ADDNEWTAG:\r\n            return addNewTag(action.payload.Tags, action.payload.CharactersSRS)\r\n        case CharacterSRSactionTypes.REMOVETAG:\r\n            return removeTag(action.payload.Tags, action.payload.CharactersSRS)\r\n        case CharacterSRSactionTypes.EDITSINGLETAG:\r\n            return editSingleTag(action.payload.NewTag, action.payload.OldTagTitle, action.payload.CharactersSRS)\r\n        case CharacterSRSactionTypes.EDITLISTITEM:\r\n            return editListItem(action.payload.Content[0], action.payload.CharactersSRS)\r\n        case CharacterSRSactionTypes.EDITLISTITEMINBULK:\r\n            return editListItemsInBulk(action.payload.Content, action.payload.CharactersSRS)\r\n        case CharacterSRSactionTypes.ADDNEWCARDSTODECK:\r\n            return addNewCardToDeck(action.payload.Content, action.payload.CharactersSRS)\r\n        case CharacterSRSactionTypes.CREATENEWDECK:\r\n            return createDeck(action.payload.Content, action.payload.CharactersSRS)\r\n        case CharacterSRSactionTypes.DELETEOREDITCARDORDER:\r\n            return deleteOrEditCardOrder(action.payload.CharsToBeDeleted, action.payload.OrderToBeChanged, action.payload.CharactersSRS)\r\n        case CharacterSRSactionTypes.REPLACESETTINGS_FILTERCARDSBYTAG:\r\n            return replacesettings_filtercardsbytag(action.payload.SettingsToReplace, action.payload.CharactersSRS)\r\n        default:\r\n            return state\r\n    }\r\n}\r\nexport default characterSRSreducer","import {FlashCard} from \"../../interfaces/flashcard\";\r\nimport {PreviousCharactersActionTypes} from \"../action-types/previousCharactersActionTypes\";\r\nimport {PreviousCharacterAction} from \"../actions/previousCharactersAction\";\r\n\r\nconst initialState: [FlashCard[], FlashCard[], FlashCard[]] = [[],[],[]]\r\n\r\nconst addToPreviousCharacters = (newContent: FlashCard, exixtingState: [FlashCard[], FlashCard[], FlashCard[]]): [FlashCard[], FlashCard[], FlashCard[]] => {\r\n    const newState: [FlashCard[], FlashCard[], FlashCard[]] =  [[...exixtingState[0], newContent], exixtingState[1], [...exixtingState[2], newContent]]\r\n    return newState;\r\n}\r\n\r\nfunction substractFromPreviousCharacters(newContent: FlashCard, exixtingState: [FlashCard[], FlashCard[], FlashCard[]]) {\r\n    const newState: [FlashCard[], FlashCard[], FlashCard[]] =  [exixtingState[0], [...exixtingState[1], newContent], [...exixtingState[2], newContent]]\r\n    return newState;\r\n}\r\n\r\nconst previousCharactersReducer = (state: [FlashCard[], FlashCard[], FlashCard[]] = initialState, action: PreviousCharacterAction): [FlashCard[], FlashCard[], FlashCard[]] => {\r\n\r\n    switch (action.type) {\r\n        case PreviousCharactersActionTypes.ADDTOPREVIOUSCHARACTERS:\r\n            return addToPreviousCharacters(action.payload.newContent, action.payload.Content)\r\n        case PreviousCharactersActionTypes.SUBSTRACTFROMPREVIOUSCHARACTERS:\r\n            return substractFromPreviousCharacters(action.payload.newContent, action.payload.Content)\r\n        default:\r\n            return state\r\n    }\r\n}\r\nexport default previousCharactersReducer","import {CardDisplayAction} from \"../actions/cardDisplayAction\";\r\nimport {CardDisplayTypes} from \"../action-types/cardDisplayTypes\";\r\nimport CardDisplay from \"../../interfaces/cardDisplay\";\r\n\r\nconst initialState: CardDisplay = {\r\n    showPrimaryCardInfo: false,\r\n    showSecondaryCardInfo: false,\r\n    readAloud: false\r\n}\r\n\r\nconst changeStateReducer = (state: CardDisplay = initialState, action: CardDisplayAction): CardDisplay => {\r\n    switch (action.type) {\r\n        case CardDisplayTypes.CHANGESTATE:\r\n            return action.payload.newContent\r\n        default:\r\n            return state\r\n    }\r\n}\r\nexport default changeStateReducer","import {combineReducers} from \"redux\";\r\nimport characterSRSreducer from \"./characterSRSreducer\"\r\nimport previousCharactersReducer from \"./previousCharactersReducer\";\r\nimport cardDisplayReducers from \"./cardDisplayReducers\";\r\n\r\nconst reducers = combineReducers({\r\n    cardDisplay: cardDisplayReducers,\r\n    characterSRS: characterSRSreducer,\r\n    previousCharacters: previousCharactersReducer\r\n});\r\n\r\nexport default reducers;\r\n\r\nexport type State = ReturnType<typeof reducers>\r\n","import {createStore, applyMiddleware} from \"redux\";\r\nimport reducers from \"./reducers\";\r\nimport thunk from \"redux-thunk\"\r\n\r\n\r\nexport const store = createStore(\r\n    reducers,\r\n    {},\r\n    applyMiddleware(thunk)\r\n)\r\n","import {FlashCard} from \"../../../interfaces/flashcard\";\r\n\r\n//characters added to deck (reviewNumber > 0) and not forbidden, sorted by review priority\r\nexport const getReviewPriority = (allContentItems: FlashCard[], forbiddenCharacters: FlashCard[]): FlashCard[] => {\r\n    const forbiddenCharacterNumbers: number[] = forbiddenCharacters.map(eachContent => eachContent.cardNumber)\r\n    const contentThatCanBepracticed: FlashCard[] = allContentItems.filter(eachContent => eachContent.repetitionValue > 0)\r\n    const nonProhibited: FlashCard[] = contentThatCanBepracticed.filter(eachContent => {\r\n        return (forbiddenCharacterNumbers && forbiddenCharacterNumbers.indexOf(eachContent.cardNumber) === -1)\r\n    })\r\n    const nonProhibitedSorted: FlashCard[] = calculateReviewPriority(nonProhibited)\r\n    return nonProhibitedSorted\r\n}\r\n\r\nconst calculateReviewPriority = (input: FlashCard[]): FlashCard[] => {\r\n    const sortContent: FlashCard[] = splitIntoReviewNumbers(input)\r\n        .map(eachByReview =>\r\n            splitIntoHistoryValues(eachByReview)\r\n                .map(eachByHistory =>\r\n                    splitIntoDateStrings(eachByHistory)\r\n                        .map(eachByDate =>\r\n                            splitIntoRandomSorted(eachByDate).flat(1)\r\n                        ).flat(1)\r\n                ).flat(1)\r\n        ).flat(1)\r\n    return sortContent\r\n}\r\n\r\nconst splitIntoReviewNumbers = (contentThatCanBePracticed: FlashCard[]): FlashCard[][] => {\r\n    var allReviewNumbers: number[] = Array.from(\r\n        new Set(contentThatCanBePracticed.map((item=> item.repetitionValue))))\r\n    var sortedReviewNumbers: number[] = allReviewNumbers.sort((n1,n2) => n1 - n2);\r\n    var resultArray: FlashCard[][] = sortedReviewNumbers.map(eachNumber => {\r\n        return contentThatCanBePracticed.filter(item => item.repetitionValue === eachNumber)\r\n    })\r\n    return resultArray;\r\n}\r\n\r\nconst splitIntoHistoryValues = (contentThatCanBePracticed: FlashCard[]): FlashCard[][] => {\r\n    var allHistorySums: number[] = Array.from(new Set(contentThatCanBePracticed.map((item => getSumOfHistory(item)))))\r\n    var sortedHustorySums: number[] = allHistorySums.sort((n1,n2) => n1 - n2);\r\n    var resultArray: FlashCard[][] = sortedHustorySums.map(eachNumber => {\r\n        return contentThatCanBePracticed.filter(item => getSumOfHistory(item) === eachNumber)\r\n    })\r\n    return resultArray;\r\n}\r\n\r\nfunction getSumOfHistory(item: FlashCard): number {\r\n    const history: number[] = item.repetitionHistory\r\n    if (history === null ||\r\n        history === undefined ||\r\n        history.length == 0) {\r\n        return 0\r\n    }else {\r\n        try {\r\n            const result: number = history.reduce((sum,current) => sum + current, 0)\r\n            return result\r\n        }catch (e) {\r\n            return 0\r\n        }\r\n    }\r\n}\r\n\r\nconst splitIntoDateStrings = (contentThatCanBePracticed: FlashCard[]): FlashCard[][] => {\r\n    const allLastPracticedDatesString: string[] = Array.from(new Set(contentThatCanBePracticed.map((item=> item.dateOfLastReview))))\r\n    const allLastPracticedDatesCorrectString: string[] = allLastPracticedDatesString.filter(eachDate => isCorrectDateString(eachDate))\r\n    const allLastPracticedDatesSorted: Date[] = allLastPracticedDatesCorrectString.sort().map(item => new Date(item))\r\n    const backToString: string[] = allLastPracticedDatesSorted.map(eachDate => eachDate.toISOString().substr(0,10))\r\n    const resultArray: FlashCard[][] = backToString.map(eachDateString => {\r\n        return contentThatCanBePracticed.filter(item => item.dateOfLastReview === eachDateString)\r\n    })\r\n    return resultArray;\r\n}\r\n\r\nconst splitIntoRandomSorted = (contentThatCanBePracticed: FlashCard[]): FlashCard[][] => {\r\n    const seed: number = getSeedFromFlashCards(contentThatCanBePracticed)\r\n    const charNumbers: number[] = Array.from(new Set(contentThatCanBePracticed.map((item=> item.cardNumber))))//.sort()\r\n    const randomSortedNumbers = shuffle(charNumbers, seed)\r\n    const resultArray: FlashCard[][] = randomSortedNumbers.map(eachNumber => {\r\n        return contentThatCanBePracticed.filter(item => item.cardNumber === eachNumber)\r\n    })\r\n    return resultArray;\r\n}\r\n\r\nfunction getSeedFromFlashCards(contentThatCanBePracticed: FlashCard[]): number {\r\n    const sumOfReviewNumbers: number = contentThatCanBePracticed.map(item => item.repetitionValue).reduce(function (a, b) {\r\n        return a + b;\r\n    }, 0);\r\n    return sumOfReviewNumbers;\r\n}\r\n\r\n//Fisher-Yates\r\n//https://stackoverflow.com/questions/16801687/javascript-random-ordering-with-seed\r\nfunction shuffle(array: number[], seed: number): number[] {\r\n    var m = array.length, t, i;\r\n    // While there remain elements to shuffle…\r\n    while (m) {\r\n        // Pick a remaining element…\r\n        i = Math.floor(random(seed) * m--);\r\n        // And swap it with the current element.\r\n        t = array[m];\r\n        array[m] = array[i];\r\n        array[i] = t;\r\n        ++seed\r\n    }\r\n    return array;\r\n}\r\n\r\nfunction random(seed: number): number {\r\n    var x = Math.sin(seed++) * 10000;\r\n    return x - Math.floor(x);\r\n}\r\n\r\n//dateString format: yyyy-mm-dd\r\nconst isCorrectDateString = (dateString: string): boolean => {\r\n    if (!dateString) {return false}\r\n    if (!(dateString.length === 10)) {return false}\r\n    if (!(dateString.substr(4,1) === \"-\")) {return false}\r\n    if (!(dateString.substr(7,1) === \"-\")) {return false}\r\n    if (!Number(dateString.substr(0,4))) {return false}\r\n    if (!Number(dateString.substr(5,2))) {return false}\r\n    if (!Number(dateString.substr(8,2))) {return false}\r\n    return true\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import characterSRSlogic from \"../../../interfaces/characterSRSlogic\";\r\nimport {FlashCard} from \"../../../interfaces/flashcard\";\r\nimport {getReviewPriority} from \"./calculateContentReviewPriority\";\r\n\r\nexport const doCalculateNextCharacter = (input: characterSRSlogic): characterSRSlogic => {\r\n    const tenMostRecent: FlashCard[] = getMostRecentlyPracticed(input, 10)\r\n    const reviewPrioritySorted: FlashCard[] = getReviewPriority(input.characterSRS.cards, tenMostRecent)\r\n    if (reviewPrioritySorted.length === 0){\r\n        //there are no characters that can be shown\r\n        const returnObject: characterSRSlogic = {\r\n            currentContent: input.currentContent,\r\n            mostRecentContentObjects: input.mostRecentContentObjects,\r\n            characterSRS: input.characterSRS,\r\n            notEnoughCharacters: true\r\n        }\r\n        return returnObject\r\n    }else {\r\n        const firstPriority: FlashCard = reviewPrioritySorted[0]\r\n        const returnObject: characterSRSlogic = {\r\n            currentContent: firstPriority,\r\n            mostRecentContentObjects: input.mostRecentContentObjects,\r\n            characterSRS: input.characterSRS,\r\n            notEnoughCharacters: false\r\n        }\r\n        return returnObject\r\n    }\r\n}\r\n\r\nconst getMostRecentlyPracticed = (input: characterSRSlogic, maxLengthInteger: number): FlashCard[] => {\r\n    const recentlyPracticed: FlashCard[] = input.mostRecentContentObjects\r\n    let result: FlashCard[] = new Array()\r\n    if (!recentlyPracticed) {\r\n        result = []\r\n    }else if (recentlyPracticed.length < maxLengthInteger) {\r\n        result = recentlyPracticed\r\n    }else {\r\n        result = recentlyPracticed.slice(0,maxLengthInteger)\r\n    }\r\n    return result\r\n}\r\n\r\n\r\n\r\n\r\n","import {doCalculateNextCharacter} from \"./calculateCharacterSRSorder\";\r\nimport characterSRSlogic from \"../../../interfaces/characterSRSlogic\";\r\n\r\nexport const calculateNextCharacter = (input: characterSRSlogic): characterSRSlogic => {\r\n    const result = doCalculateNextCharacter(input)\r\n    return result\r\n}\r\n\r\nexport default calculateNextCharacter","import {FormEvent} from \"react\";\r\n\r\nexport const parseNumberListInput = (input: string): number[] => {\r\n    const split: string[] = input.split(\",\")//split on comma\r\n    const numberlist: number[] = split.filter(x => Number(x)).map(x=>Number(x))\r\n    if (numberlist.length > 0) {\r\n        return numberlist\r\n    }else {\r\n        return []\r\n    }\r\n}\r\n\r\nfunction parseStringListInput(input: string): string[] {\r\n    const split: string[] = input.split(\",\")\r\n    const stringList: string[] = split.map(x=>x.replace(/ /g,'').trim()).filter(x=>x.length>0)\r\n    if (stringList.length>0) {\r\n        return stringList\r\n    }else {\r\n        return []\r\n    }\r\n}\r\n\r\nexport const editTagList = (htmlelement: React.FormEvent<HTMLLIElement>, defaultValue: string[], mustBeIn: string[]): string[] => {\r\n    const rawValue: string = htmlelement.currentTarget.textContent ? htmlelement.currentTarget.textContent : \"\"\r\n    const textvalue: string[] = parseStringListInput(rawValue)\r\n    const onlyLegitimateTextValues: string[] = textvalue\r\n        .filter(x=>mustBeIn.includes(x))\r\n        .filter(function(elem, index, self) {\r\n            return index === self.indexOf(elem);\r\n        }).sort()\r\n    if (textvalue.length === 0){\r\n        return []\r\n    }else if (textvalue.length > onlyLegitimateTextValues.length) {\r\n        return defaultValue\r\n    }else {\r\n        return onlyLegitimateTextValues\r\n    }\r\n}\r\n\r\nexport const displayStringList = (input: string[]): string => {\r\n    if (input.length > 0) {\r\n        const display: string = input.join(\",\")\r\n        return display\r\n    }else {\r\n        return \"\"\r\n    }\r\n}\r\n\r\nexport const editNumberList = (htmlelement: FormEvent<HTMLElement>, defaultValue: number[]): number[] => {\r\n    const rawValue: string = htmlelement.currentTarget.textContent ? htmlelement.currentTarget.textContent : \"\"\r\n    const textvalue = parseNumberListInput(rawValue)\r\n    if (!textvalue) {\r\n        return defaultValue\r\n    }else {\r\n        return textvalue\r\n    }\r\n}\r\n\r\nexport const displayNumberList = (input: number[]): string => {\r\n    if (input.length > 0) {\r\n        const display: string = input.map(x => x.toString()).join(\",\")\r\n        return display\r\n    }else {\r\n        return \"\"\r\n    }\r\n}\r\n\r\nexport const editNumberValue = (htmlelement: FormEvent<HTMLElement>, defaultValue: number): number => {\r\n    const textvalue: string | null = htmlelement.currentTarget.textContent\r\n    if (!(textvalue == null) && !Number.isInteger(parseInt(textvalue))) {\r\n        return defaultValue\r\n    }else {\r\n        const finalresult: number = Number(textvalue)\r\n        return finalresult\r\n    }\r\n}\r\n\r\nexport const editStringvalue = (htmlelement: FormEvent<HTMLElement>, defaultValue: string): string => {\r\n    const textvalue = htmlelement.currentTarget.textContent\r\n    if (!textvalue) {\r\n        return defaultValue\r\n    }else {\r\n        const finalresult: string = textvalue ? textvalue : defaultValue\r\n        return finalresult\r\n    }\r\n}\r\n\r\nexport default {editNumberValue, editStringvalue, editNumberList, displayNumberList, parseNumberListInput, displayStringList,\r\n    editTagList\r\n}","import {FlashCard} from \"../../interfaces/flashcard\";\r\nimport {FlashCardDeck} from \"../../interfaces/flashcarddeck\";\r\n\r\nexport const getCardSimpleDisplayInfo = (cardNumber: number, currentState: FlashCardDeck): string => {\r\n    const cardExists: boolean = cardExistInDeck(cardNumber, currentState)\r\n    if (cardExists) {\r\n        const card = getFlashCard(cardNumber, currentState)\r\n        if (card.frontSide.length > 10) {\r\n            return cardNumber.toString()+\"_\"+card.frontSide.slice(0,9)+\"...\"\r\n        }else {\r\n            return cardNumber.toString()+\"_\"+card.frontSide\r\n        }\r\n    }else {\r\n        return cardNumber.toString()\r\n    }\r\n}\r\n\r\nexport const getTagFromDeck = (tagName: String, characterSRSstate: FlashCardDeck): String => {\r\n    const record: Record<string, string> = characterSRSstate.tags\r\n    const primitiveString: string = tagName.toString()\r\n    const tagdata: String = record[primitiveString]\r\n    if (tagdata && tagdata.length > 0) {\r\n        return tagdata\r\n    }\r\n    return \"\"\r\n}\r\n\r\nexport const cardExistInDeck = (cardNumber: number, currentState: FlashCardDeck): boolean => {\r\n    const cardCandidates: FlashCard[]  = currentState.cards.filter(x=>{\r\n        return (x.cardNumber === cardNumber)\r\n    })\r\n    if (cardCandidates.length > 0) {\r\n        return true\r\n    }else {\r\n        return false\r\n    }\r\n}\r\n\r\nexport const getFlashCard = (cardNumber: number, currentState: FlashCardDeck): FlashCard => {\r\n    const cardCandidates: FlashCard[] = currentState.cards.filter(x => {\r\n        return (x.cardNumber === cardNumber)\r\n    })\r\n    if (cardCandidates.length > 0) {\r\n        return cardCandidates[0]\r\n    } else {\r\n        const newCard: FlashCard = {\r\n            cardNumber: 0,\r\n            cardName: \"\",\r\n            frontSide: \"\",\r\n            backSide: \"\",\r\n            primaryInfo: \"\",\r\n            secondaryInfo: \"\",\r\n            notableCards: [],\r\n            dateOfLastReview: \"\",\r\n            repetitionValue: 0,\r\n            repetitionHistory: [],\r\n            tags: []\r\n        }\r\n        return newCard\r\n    }\r\n}\r\n\r\nexport function mapkeys<K>(m: Map<K, any>): K[]\r\nexport function mapkeys(m: { [key: string]: any }): string[]\r\nexport function mapkeys (m: any): any {\r\n    if (m instanceof Map) return Array.from(m.keys())\r\n    return Object.keys(m)\r\n}","import React from 'react';\r\n\r\ninterface ScrollableTextAreaProps {\r\n    text: string;\r\n}\r\n\r\n\r\nconst ScrollableTextArea: React.FC<ScrollableTextAreaProps> = ({ text }) => {\r\n    return (\r\n        <textarea\r\n            value={text}\r\n            style={{ width: '300px', height: '200px', overflowY: 'auto' }}\r\n            readOnly\r\n        />\r\n    );\r\n};\r\n\r\nexport default ScrollableTextArea;","import React, { useEffect, useRef } from 'react';\r\nimport FlashCardStateManipulation from \"../applogic/FlashcardDisplayLogic/FlashCardStateManipulation\";\r\n\r\ninterface EditableTextAreaProps {\r\n    showCard: boolean;\r\n    showArea: boolean;\r\n    info: string;\r\n    infoStringToDisplay: string;\r\n    onInputChange: (event: React.ChangeEvent<HTMLTextAreaElement>) => void;\r\n}\r\n\r\nconst EditableTextArea: React.FC<EditableTextAreaProps> =\r\n    ({ showCard, showArea, info, onInputChange }) => {\r\n\r\n        const textareaRef = useRef<HTMLTextAreaElement>(null);\r\n\r\n        // Function to adjust height of textarea\r\n        const adjustTextareaHeight = () => {\r\n            if (textareaRef.current) {\r\n                const scrollHeight = textareaRef.current.scrollHeight;\r\n                const newHeight = scrollHeight + 20; // Add 20 pixels to the scrollHeight\r\n                textareaRef.current.style.height = `${newHeight}px`;\r\n            }\r\n        };\r\n\r\n        useEffect(() => {\r\n            adjustTextareaHeight();\r\n        }, [info]); // Adjust height whenever `info` changes\r\n\r\n        const handleChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {\r\n            onInputChange(event);\r\n            adjustTextareaHeight();\r\n        };\r\n\r\n        return (showArea && showCard) ? (\r\n            <textarea\r\n                ref={textareaRef}\r\n                value={info}\r\n                onChange={handleChange}\r\n                style={{ width: '300px', minHeight: '200px', overflowY: 'hidden', resize: 'both' }}\r\n            />\r\n        ) : null;\r\n    };\r\n\r\nexport default EditableTextArea;","import classes from \"./CardComponent.module.css\"\r\nimport {PropsWithChildren, ReactElement, useEffect, useState} from \"react\";\r\nimport React from \"react\";\r\nimport {FlashCard} from \"../interfaces/flashcard\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport {bindActionCreators} from \"redux\";\r\nimport { characterSRSactionCreators, State } from '../state/index';\r\nimport FlashCardStateManipulation from \"../applogic/FlashcardDisplayLogic/FlashCardStateManipulation\";\r\nimport {\r\n    cardExistInDeck,\r\n    getCardSimpleDisplayInfo,\r\n    getFlashCard,\r\n    getTagFromDeck\r\n} from \"../applogic/flashcardHelperFunctions/gettingFlashCards\";\r\nimport CardDisplay from \"../interfaces/cardDisplay\";\r\nimport ScrollableTextArea from \"./ScrollableTextAreaComponent\";\r\nimport EditablePrimaryInfo from \"./EditableTextAreaComponent\";\r\nimport EditableTextAreaComponent from \"./EditableTextAreaComponent\";\r\nimport EditableTextArea from \"./EditableTextAreaComponent\";\r\n\r\nconst CardComponent: React.FC<{content: FlashCard, show: boolean, cardDisplay: CardDisplay, alwaysShow: boolean}> =\r\n    (props: PropsWithChildren<{content: FlashCard, show: boolean, cardDisplay: CardDisplay, alwaysShow: boolean}>) => {\r\n\r\n    const showData: boolean = props.show || props.alwaysShow\r\n    const dispatch = useDispatch();\r\n    const {editListItem} = bindActionCreators(characterSRSactionCreators, dispatch)\r\n    const characterSRSstate = useSelector(\r\n        (state: State) => state.characterSRS\r\n    )\r\n\r\n    const [cardToDisplay, setCardToDisplay] = useState<number>(-1)\r\n    const [showNotableChardButtons, setShowNotableChardButtons] = useState<boolean>(false)\r\n    const [tagToDisplay, setTagToDisplay] = useState<String>(\"\")\r\n    const [showTagButtons, setShowTagButtons] = useState<boolean>(false)\r\n    //const [localCard, setLocalCard] = useState<FlashCard>(props.content)\r\n\r\n    // primary and secondary information\r\n    const [tempPrimaryInfo, setTempPrimaryInfo] = useState(props.content.primaryInfo);\r\n\r\n    useEffect(() => {\r\n        setTempPrimaryInfo(props.content.primaryInfo);\r\n    }, [props.content.secondaryInfo]);\r\n\r\n\r\n    const handlePrimaryInfoInputChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {\r\n            // handle the input change here, maybe with something like:\r\n        setTempPrimaryInfo(event.target.value);\r\n    };\r\n    const [tempSecondaryInfo, setTempSecondaryInfo] = useState(props.content.secondaryInfo);\r\n    useEffect(() => {\r\n        setTempSecondaryInfo(props.content.secondaryInfo);\r\n    }, [props.content.secondaryInfo]);\r\n\r\n    const handleSecondaryInfoInputChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {\r\n        setTempSecondaryInfo(event.target.value);\r\n    };\r\n\r\n\r\n    const content: FlashCard = props.content\r\n    var tempReviewValue: number = props.content.repetitionValue\r\n    var tempDateOfLastReview: string = props.content.dateOfLastReview\r\n    var tempKeyword: string = props.content.frontSide\r\n    var tempNotableCards: number[] = props.content.notableCards\r\n    var tempCardName: string = props.content.cardName\r\n    var tempTagsOnCard: string[] = props.content.tags\r\n\r\n    const saveEdit = () => {\r\n        var changesMade: boolean = false\r\n        if (!(tempReviewValue === props.content.repetitionValue)) {changesMade = true}\r\n        if (!(tempDateOfLastReview === props.content.dateOfLastReview)) {changesMade = true}\r\n        if (!(tempKeyword === props.content.frontSide)) {changesMade = true}\r\n        if (!(tempPrimaryInfo === props.content.primaryInfo)) {changesMade = true}\r\n        if (!(tempSecondaryInfo === props.content.secondaryInfo)) {changesMade = true}\r\n        if (!(tempNotableCards === props.content.notableCards)) {changesMade = true}\r\n        if (!(tempCardName === props.content.cardName)) {changesMade = true}\r\n        if (!(tempTagsOnCard === props.content.tags)) {changesMade = true}\r\n\r\n        const newContentObject: FlashCard = {\r\n            cardNumber: props.content.cardNumber,\r\n            cardName: tempCardName,\r\n            frontSide: tempKeyword,\r\n            backSide: props.content.backSide,\r\n            primaryInfo: tempPrimaryInfo,\r\n            secondaryInfo: tempSecondaryInfo,\r\n            notableCards: tempNotableCards,\r\n            dateOfLastReview: tempDateOfLastReview,\r\n            repetitionValue: tempReviewValue,\r\n            repetitionHistory: props.content.repetitionHistory,\r\n            tags: tempTagsOnCard\r\n        }\r\n\r\n        if (changesMade) {\r\n            editListItem(newContentObject, characterSRSstate)\r\n        }\r\n    }\r\n\r\n    const renderFrontSide = (): ReactElement => {\r\n        const ordinaryFrontSide: ReactElement = <section> <li onInput={(e) =>\r\n            tempKeyword = FlashCardStateManipulation.editStringvalue(e, props.content.frontSide)}\r\n                                                              contentEditable=\"true\">\r\n            {content.frontSide}</li> </section>\r\n        const audioFrontSide: ReactElement = <section> <li>audio</li> </section>\r\n        if (!showData && props.cardDisplay.readAloud) {\r\n            return audioFrontSide\r\n        } else {\r\n            return ordinaryFrontSide\r\n        }\r\n    }\r\n\r\n    function selectText() {\r\n        const input = (document.getElementById('audioid') as HTMLFormElement)//content.backSide;\r\n        try {\r\n            input.focus()\r\n            input.select()\r\n        }catch (e) {\r\n            console.log(\"no audio id\")\r\n            console.log(e)\r\n        }\r\n    }\r\n\r\n    const displayAudio = () => {\r\n        if (props.cardDisplay.readAloud) {\r\n            return <section>\r\n                {displayAudioFieldWhenBacksideIsShown()}\r\n                {displayAudioFieldWhenFrontsideIsShown()}\r\n                {<button type=\"button\" onClick={() => selectText()}>selectText</button>}\r\n            </section>\r\n        }else {\r\n            return <section></section>\r\n        }\r\n    }\r\n\r\n    const displayAudioFieldWhenBacksideIsShown = () => {\r\n        const withAudio: ReactElement = <section>\r\n            <textarea id=\"audioid\" className={classes.audioText} >{props.content.backSide}</textarea>\r\n        </section>\r\n        if (!showData) {\r\n            return withAudio\r\n        }else {\r\n            return <section></section>\r\n        }\r\n    }\r\n\r\n    const displayAudioFieldWhenFrontsideIsShown = () => {\r\n        const withAudio: ReactElement = <section>\r\n            <textarea id=\"audioid\" className={classes.audioText} >{props.content.backSide}</textarea>\r\n        </section>\r\n        if (showData) {\r\n            return withAudio\r\n        }else {\r\n            return <section></section>\r\n        }\r\n    }\r\n\r\n    const displayOriginalCharacter = (content: FlashCard): JSX.Element => {\r\n\r\n        const testCard = \"\"\r\n        const display: JSX.Element = <section>\r\n            <ul>\r\n                { showData ? <li className={classes.characterListElement}>{props.content.backSide}</li> : <li className={classes.characterListElement}></li>}\r\n                {<section><br/></section>}\r\n                { showData ? <li onInput={(e) =>\r\n                    tempCardName = FlashCardStateManipulation.editStringvalue(e, props.content.cardName)}\r\n                                   contentEditable=\"true\">\r\n                    {content.cardName}</li> : <li></li>}\r\n                { showData ? <li>{content.cardNumber}</li> : <li></li>}\r\n                { showData ? <li onInput={(e) =>\r\n                    tempReviewValue = FlashCardStateManipulation.editNumberValue(e, props.content.repetitionValue)}\r\n                                   contentEditable=\"true\">\r\n                    {content.repetitionValue}</li> : <li></li>}\r\n                { showData ? <li onInput={(e) =>\r\n                    tempDateOfLastReview = FlashCardStateManipulation.editStringvalue(e, props.content.dateOfLastReview)}\r\n                                   contentEditable=\"true\">\r\n                    {content.dateOfLastReview}</li> : <li></li>}\r\n                { showData ? <li>{content.repetitionHistory}</li> : <li></li>}\r\n                {renderFrontSide()}\r\n                { showData ? <li onInput={(e) =>\r\n                    tempNotableCards = FlashCardStateManipulation.editNumberList(e, props.content.notableCards)}\r\n                    contentEditable=\"true\">\r\n                    {FlashCardStateManipulation.displayNumberList(content.notableCards)}</li> : <li></li>}\r\n                { showData ? <li onInput={(e) =>\r\n                    tempTagsOnCard = FlashCardStateManipulation.editTagList(e, props.content.tags,\r\n                        Object.keys(characterSRSstate.tags))}\r\n                    contentEditable=\"true\">\r\n                    {FlashCardStateManipulation.displayStringList(content.tags)}</li>  : <li></li>}\r\n\r\n\r\n                <li><EditableTextArea\r\n                    showCard={showData}\r\n                    showArea={props.cardDisplay.showPrimaryCardInfo}\r\n                    info={tempPrimaryInfo}//props.content.primaryInfo\r\n                    infoStringToDisplay={\"primary info:\"}\r\n                    onInputChange={handlePrimaryInfoInputChange}\r\n                /></li>\r\n\r\n                <li><EditableTextArea\r\n                    showCard={showData}\r\n                    showArea={props.cardDisplay.showSecondaryCardInfo}\r\n                    info={tempSecondaryInfo}//props.content.secondaryInfo\r\n                    infoStringToDisplay={\"secondary info:\"}\r\n                    onInputChange={handleSecondaryInfoInputChange}\r\n                /></li>\r\n\r\n            </ul>\r\n        </section>\r\n        return display\r\n    }\r\n\r\n\r\n\r\n\r\n        /*\r\n        { props.show&&props.cardDisplay.showPrimaryCardInfo ? <li onInput={(e) =>\r\n            tempPrimaryInfo = FlashCardStateManipulation.editStringvalue(e, props.content.primaryInfo)}\r\n                           contentEditable=\"true\">\r\n            {convertStringToListOfStrings(content.primaryInfo, \"primary info:\")}</li> : <li></li>}\r\n\r\n        { props.show&&props.cardDisplay.showSecondaryCardInfo ? <li onInput={(e) =>\r\n            tempSecondaryInfo = FlashCardStateManipulation.editStringvalue(e, props.content.secondaryInfo)}\r\n                                                contentEditable=\"true\">\r\n            {convertStringToListOfStrings(content.secondaryInfo, \"secondary info:\")}</li> : <li></li>}*/\r\n\r\n    const displayNotableCard = (input: FlashCard): JSX.Element  => {\r\n        const display: JSX.Element = <section>\r\n            <ul>\r\n                <li className={classes.characterListElement}>{input.backSide}</li>\r\n                <li>{input.cardName}</li>\r\n                <li>{input.cardNumber}</li>\r\n                <li>{input.repetitionValue}</li>\r\n                <li>{input.dateOfLastReview}</li>\r\n                <li>{input.repetitionHistory}</li>\r\n                <li>{input.frontSide}</li>\r\n                <li>{FlashCardStateManipulation.displayNumberList(input.notableCards)}</li>\r\n                <li>{props.cardDisplay.showPrimaryCardInfo ?\r\n                        <ScrollableTextArea text={input.primaryInfo}/> : null}</li>\r\n                <li>{props.cardDisplay.showSecondaryCardInfo ?\r\n                        <ScrollableTextArea text={input.secondaryInfo}/> : null}</li>\r\n            </ul>\r\n        </section>\r\n        return display\r\n    }\r\n//{props.cardDisplay.showPrimaryCardInfo ? <li>{input.primaryInfo}</li> : <li></li>}\r\n/*\r\n\r\n                {props.cardDisplay.showPrimaryCardInfo ? <li>{input.primaryInfo}</li> : <li></li>}s\r\n                {props.cardDisplay.showSecondaryCardInfo ? <li>{input.secondaryInfo}</li> : <li></li>}\r\n\r\n    const ScrollableTextArea = (text: string) => {\r\n        return (\r\n            <textarea\r\n                value={text}\r\n                style={{ width: '300px', height: '200px', overflowY: 'auto' }}\r\n                readOnly\r\n            />\r\n        );\r\n    };\r\n*/\r\n\r\n    const toggleShowNotableCards = () => {\r\n        if (showNotableChardButtons) {\r\n            setCardToDisplay(-1)\r\n            setShowNotableChardButtons(!showNotableChardButtons)\r\n        }\r\n        setShowNotableChardButtons(!showNotableChardButtons)\r\n    }\r\n\r\n    const toggleShowTagButtons = () => {\r\n        if (showTagButtons) {\r\n            setTagToDisplay(\"\")\r\n            setShowTagButtons(!showTagButtons)\r\n        }\r\n        setShowTagButtons(!showTagButtons)\r\n    }\r\n\r\n    const displayNotableCardButtons = (): JSX.Element => {\r\n        if (showNotableChardButtons) {\r\n            const result: JSX.Element = <section>{generateListOfCardButtons(props.content.cardNumber)}</section>\r\n            return result\r\n        }else {\r\n            return <section></section>\r\n        }\r\n    }\r\n    const generateListOfCardButtons = (currentCard: number): JSX.Element => {\r\n        let localCard = getFlashCard(currentCard, characterSRSstate)\r\n        if (localCard.notableCards.length > 0) {\r\n            const localList: JSX.Element[] = localCard.notableCards.map(x=>{\r\n                return <button type=\"button\" onClick={() => setCardToDisplay(x)}>\r\n                    {getCardSimpleDisplayInfo(x, characterSRSstate)}</button>\r\n            })\r\n            const result: JSX.Element = <section><ul>\r\n                <li><button type=\"button\" onClick={() => setCardToDisplay(-1)}>{currentCard.toString()}</button></li>\r\n                {\r\n                    localList\r\n                }</ul></section>\r\n            return result\r\n        }else {\r\n            return <section><p>no cards</p></section>\r\n        }\r\n    }\r\n\r\n    const displayTagButtons = (): JSX.Element => {\r\n        if (showTagButtons) {\r\n            const result: JSX.Element = <section>{generateListOfTagButtons(props.content.tags)}</section>\r\n            return result\r\n        }else {\r\n            return <section></section>\r\n        }\r\n    }\r\n\r\n    const generateListOfTagButtons = (tags: String[]): JSX.Element => {\r\n        if (tags == null || !tags || tags.length == undefined || tags.length < 1) {\r\n            return <section>No tags to show</section>\r\n        }\r\n        const localList: JSX.Element[] = tags.map(x=>{\r\n            return <button type=\"button\" onClick={\r\n                () => setTagTextFunction(x) }>\r\n                {x}</button>\r\n        })\r\n        const result: JSX.Element = <section><ul>\r\n            {localList}</ul></section>\r\n        return result\r\n    }\r\n\r\n    const setTagTextFunction = (tagName: String) => {\r\n        setTagToDisplay(tagName)\r\n    }\r\n\r\n    const displayCard = (content: FlashCard): JSX.Element => {\r\n        if (cardToDisplay > -1 && cardExistInDeck(cardToDisplay, characterSRSstate)) {\r\n            const newCard: FlashCard = getFlashCard(cardToDisplay, characterSRSstate);\r\n            return displayNotableCard(newCard)\r\n        }else {\r\n            return displayOriginalCharacter(content)\r\n        }\r\n    }\r\n\r\n    const displayTag = (): JSX.Element => {\r\n        const text: String = getTagFromDeck(tagToDisplay, characterSRSstate)\r\n        if (text && text.length > 0) {\r\n            return <section>{text}</section>\r\n        }else {\r\n            return <section></section>\r\n        }\r\n    }\r\n\r\n    return <section>\r\n        <button type=\"button\" onClick={() => saveEdit()}>saveEditOn {content.cardNumber}</button>\r\n        <button type=\"button\" onClick={() => toggleShowNotableCards()}>showNotableCardButtons{showNotableChardButtons.valueOf()}</button>\r\n        <button type=\"button\" onClick={() => toggleShowTagButtons()}>showTagButtons{showTagButtons.valueOf()}</button>\r\n        {displayNotableCardButtons()}\r\n        {displayTagButtons()}\r\n        {displayTag()}\r\n        {displayAudio()}\r\n        {displayCard(content)}\r\n    </section>\r\n}\r\n\r\nexport default CardComponent","export const SortingValueAll = ['NOTHING', 'INCLUDE', 'EXCLUDE', 'ONLY'];\r\n\r\nexport function isSortingValue(value: string): boolean{\r\n    return SortingValueAll.includes(value)\r\n}\r\n","import {FlashCard} from \"../../interfaces/flashcard\";\r\nimport {isSortingValue} from \"../../interfaces/types/sortingValue\";\r\nimport {FlashCardDeck} from \"../../interfaces/flashcarddeck\";\r\n\r\nexport const getSettings_filtercardsbytag_numbers = (currentState: FlashCardDeck): Set<number> => {\r\n    const cards: FlashCard[] = filterByTags(currentState.cards, dogetSettings_filtercardsbytag(currentState))\r\n    const cardnumbers: Set<number> = new Set(cards.map(each => each.cardNumber))\r\n    return cardnumbers\r\n}\r\n\r\nexport const getSettings_filtercardsbytag = (currentState: FlashCardDeck): FlashCard[] => {\r\n    return filterByTags(currentState.cards, dogetSettings_filtercardsbytag(currentState))\r\n}\r\n\r\nexport const dogetSettings_filtercardsbytag = (currentState: FlashCardDeck): Record<string, string> => {\r\n    const subcategoryname: string = \"filtercardsbytag\"\r\n    const settings:  Record<string, Record<string, string>> = currentState.settings\r\n    var subcategory: Record<string, string> = {}\r\n    if (settings[subcategoryname]) {\r\n        subcategory = settings[subcategoryname]\r\n    }\r\n    return subcategory\r\n}\r\n\r\nexport function filterByTags(inp: FlashCard[], localTagsFilter: Record<string, string>): FlashCard[] {\r\n    const cardsToUse: number[] = calculateFilter(inp, localTagsFilter)\r\n    const filteredCards: FlashCard[] = inp.filter(eachCard => cardsToUse.includes(eachCard.cardNumber))\r\n    return filteredCards;\r\n}\r\n\r\nexport const calculateFilter = (inp: FlashCard[], localTagsFilter: Record<string, string>):　number[] => {\r\n    var cardsToUse: number[] = []\r\n    const allNumbersFromRecord: number[] = Object.keys(localTagsFilter).map(Number).sort()\r\n    var stringsToHandle: string[] = []\r\n    for (var num in allNumbersFromRecord) {\r\n        const str: string = localTagsFilter[allNumbersFromRecord[num].toString()]\r\n        stringsToHandle.push(str)\r\n    }\r\n\r\n    var updatedCardsLists: [FlashCard[], FlashCard[]] = [[], inp]\r\n    for (var str in stringsToHandle) {\r\n        const eachstr: string = stringsToHandle[str]\r\n        updatedCardsLists = handleFilterString(eachstr, updatedCardsLists[0], updatedCardsLists[1])\r\n    }\r\n\r\n    //merge certain and uncertain\r\n    const secureCardNum: number[] = updatedCardsLists[0].map(eachCard => eachCard.cardNumber)\r\n    const uncertainNum: number[] = updatedCardsLists[1].map(eachCard => eachCard.cardNumber)\r\n    cardsToUse.push(...secureCardNum)\r\n    cardsToUse.push(...uncertainNum)\r\n    var resultSet = new Set(cardsToUse)\r\n    var result: number[] = Array.from(resultSet.values()).sort();\r\n    return result\r\n}\r\n\r\nfunction handleFilterString(eachstr: string, secureCardList: FlashCard[], uncertainCardList: FlashCard[]): [FlashCard[], FlashCard[]] {\r\n    var newSecure: FlashCard[] = secureCardList\r\n    var newUncertain: FlashCard[] = []\r\n    const tagAndType: string[] = eachstr.split(\" \")\r\n    const tag: string = tagAndType[0]\r\n    const filterLogic: string = tagAndType[1]\r\n\r\n    if (isSortingValue(filterLogic) && filterLogic == \"INCLUDE\") {\r\n        const cardsWithRelevantTag: FlashCard[] = uncertainCardList.filter(eachCard => hasTag(tag, eachCard))\r\n        newSecure.push(...cardsWithRelevantTag)\r\n        newUncertain = uncertainCardList.filter(eachCard => !hasTag(tag, eachCard))\r\n    }else if (isSortingValue(filterLogic) && filterLogic == \"EXCLUDE\") {\r\n        newUncertain = uncertainCardList.filter(eachCard => !hasTag(tag, eachCard))\r\n    }else if (isSortingValue(filterLogic) && filterLogic == \"ONLY\") {\r\n        newUncertain = uncertainCardList.filter(eachCard => hasTag(tag, eachCard))\r\n    }else {\r\n        newUncertain = uncertainCardList\r\n    }\r\n    return [newSecure, newUncertain];\r\n}\r\n\r\nconst hasTag = (tag: string, flashCard: FlashCard): boolean => {\r\n    try {\r\n        if (flashCard && flashCard.tags && flashCard.tags?.includes(tag)) {\r\n            return true\r\n        }else {\r\n            return false\r\n        }\r\n    }catch (e) {\r\n        return false\r\n    }\r\n}","\r\nimport React, {MutableRefObject, ReactElement, useEffect, useRef, useState} from \"react\";\r\nimport IPage from \"../interfaces/page\";\r\nimport {useDispatch, useSelector} from \"react-redux\";\r\nimport {bindActionCreators} from \"redux\";\r\nimport { characterSRSactionCreators,\r\n    previousCharactersActionCreators,\r\n    cardDisplayActionCreator,\r\n    State } from '../state/index';\r\nimport {FlashCard} from \"../interfaces/flashcard\";\r\nimport {FlashCardDeck} from \"../interfaces/flashcarddeck\";\r\nimport characterSRSlogic from \"../interfaces/characterSRSlogic\";\r\nimport {calculateNextCharacter} from \"../applogic/characterSRSlogic/calculateCharacterSRSorder/characterSRSlogicBoundary\";\r\nimport CardComponent from \"../components/CardComponent\";\r\nimport CardDisplay from \"../interfaces/cardDisplay\";\r\nimport {\r\n    filterByTags,\r\n    getSettings_filtercardsbytag,\r\n    getSettings_filtercardsbytag_numbers\r\n} from \"../applogic/FlashcardDisplayLogic/FlashCardFiltering\";\r\n\r\nconst Practice: React.FunctionComponent<IPage> = props => {\r\n\r\n    const addCharactersReference = useRef<HTMLInputElement | null>(null);\r\n    useEffect(()=>{addCharactersReference.current?.focus();},[])\r\n\r\n    //the current card being looked at\r\n    var currentContent: FlashCard;\r\n\r\n    const previousCard: MutableRefObject<FlashCard[]> = useRef<FlashCard[]>([]);\r\n    const [showCharacterSRSContentElement, setShowCharacterSRSContentElement] = useState<boolean>(false)\r\n    const [showPreviusCard, setShowPreviusCard] = useState<boolean>(false)\r\n    const [addMoreCharactersTextField, setAddMoreCharactersTextField] = useState<string>(\"\");\r\n\r\n    const dispatch = useDispatch();\r\n    const {editListItemInBulk} = bindActionCreators(characterSRSactionCreators, dispatch)\r\n    const characterSRSstate: FlashCardDeck = useSelector(\r\n        (state: State) => state.characterSRS\r\n    )\r\n    const {addToPreviousCharacters, substractFromPreviousCharacters} = bindActionCreators(previousCharactersActionCreators, dispatch)\r\n    const previousCharactersState: [FlashCard[], FlashCard[], FlashCard[]] = useSelector(\r\n        (state: State) => state.previousCharacters\r\n    )\r\n\r\n    const {cardDisplayChangeState} = bindActionCreators(cardDisplayActionCreator, dispatch)\r\n    const showCardDisplay: CardDisplay = useSelector(\r\n        (state: State) => state.cardDisplay\r\n    )\r\n    var cardDisplayLocalState: CardDisplay = showCardDisplay\r\n    const localTagsFilterNumbers: Set<number> = getSettings_filtercardsbytag_numbers(characterSRSstate)\r\n\r\n    const previuscharacterLocalUpdate = (newChar: FlashCard | undefined): void => {\r\n        if (newChar) {\r\n            if (\r\n                previousCard.current.length > 0 &&\r\n                previousCard.current[0].cardNumber !== newChar.cardNumber\r\n            ) {\r\n                const updatedPrevius: FlashCard[] = [newChar, ...previousCard.current];\r\n                previousCard.current = updatedPrevius.slice(0, 2); // Limit to 2 elements if needed\r\n            } else if (previousCard.current.length === 0) {\r\n                const updatedPrevius: FlashCard[] = [newChar];\r\n                previousCard.current = updatedPrevius.slice(0, 1); // Limit to 1 element\r\n            }\r\n        }\r\n    };\r\n\r\n    const todoPageContent = (): ReactElement => {\r\n        let contentOrNotEnough;\r\n        //update cards to select from, by taking filtering into account\r\n        //const localTagsFilter: Record<string, string> =\r\n        const filteredCards: FlashCard[] = characterSRSstate.cards.filter(each => localTagsFilterNumbers.has(each.cardNumber))\r\n        //const updatedSrs: FlashCardDeck = {...characterSRSstate}\r\n        const updatedSrs: FlashCardDeck = {...characterSRSstate, cards: filteredCards}\r\n\r\n        const srslogic: characterSRSlogic = {\r\n            characterSRS: updatedSrs,\r\n            currentContent: undefined,\r\n            mostRecentContentObjects: previousCharactersState[2],\r\n            notEnoughCharacters: false\r\n        }\r\n        const srscalculationResult: characterSRSlogic = calculateNextCharacter(srslogic)\r\n        if (srscalculationResult.notEnoughCharacters) {\r\n\r\n            contentOrNotEnough = <p>not enough characters. add more to deck</p>\r\n        }else {\r\n            if (srscalculationResult.currentContent) {\r\n                //set global content variable\r\n                currentContent = srscalculationResult.currentContent\r\n                previuscharacterLocalUpdate(currentContent)\r\n                contentOrNotEnough = generateCardComponent(\r\n                    srscalculationResult.currentContent,\r\n                    showCharacterSRSContentElement,\r\n                    cardDisplayLocalState,\r\n                    false)\r\n            }else {\r\n                contentOrNotEnough = <p>Content type is undefined!!! this is an error</p>\r\n            }\r\n        }\r\n        displayMostRecentCharacters(previousCharactersState)\r\n        return contentOrNotEnough\r\n    }\r\n\r\n    const showPreviusCharacter = (\r\n        localpreviusCard: FlashCard[],\r\n        localshowPreviusCard: boolean\r\n    ): ReactElement => {\r\n        console.log('Breakpoint hit with:', { localpreviusCard, localshowPreviusCard });\r\n\r\n        if (localshowPreviusCard && localpreviusCard.length > 1) {\r\n            // Access the most recent card in the array\r\n            const mostRecentCard = localpreviusCard[1];\r\n\r\n            if (mostRecentCard.cardNumber > 0) {\r\n\r\n                const cardComponent = generateCardComponent(\r\n                    mostRecentCard, // Pass the most recent card\r\n                    showCharacterSRSContentElement,\r\n                    cardDisplayLocalState,\r\n                    true\r\n                );\r\n                return cardComponent;\r\n            } else {\r\n                return <p>no previus card</p>;\r\n            }\r\n        } else {\r\n            return <section></section>;\r\n        }\r\n    };\r\n\r\n    const generateCardComponent = (\r\n        content: FlashCard, showSRSContent: boolean, cardDisplay: CardDisplay, alwaysShow: boolean) => {\r\n\r\n        return <CardComponent content={content}\r\n                       show={showSRSContent}\r\n                       cardDisplay={cardDisplay}\r\n                       alwaysShow={alwaysShow}/>\r\n    }\r\n\r\n    const displayNumberOfCharacters = (): ReactElement => {\r\n        const charactersYouWantToAdd: number = Number(addMoreCharactersTextField) ? Number(addMoreCharactersTextField) : 0\r\n        const finalCharValue: number = getNewFinalCharValue(charactersYouWantToAdd)\r\n        const allCharacters: number = characterSRSstate.cards.filter(eachContent => {\r\n            return eachContent.repetitionValue > 0\r\n        }).length\r\n        //return <p>highest character: {finalCharValue} all characters: {allCharacters} filtered: {localTagsFilterNumbers.size}</p>\r\n        return (\r\n            <section>\r\n                highest character: {finalCharValue} -\r\n                all characters: {allCharacters} -\r\n                filtered: {localTagsFilterNumbers.size}\r\n            </section>\r\n        );\r\n    }\r\n\r\n    //used to either add new character or delete old ones (remove it from the deck)\r\n    const addOrRemoveCardsToPractice = (charactersToAdd: number, addCards: boolean): FlashCard[] => {\r\n        let charsToAdd: FlashCard[];\r\n        if (addCards) {\r\n            //add cards\r\n            const sortedCharactersLowestToHighest: FlashCard[] = characterSRSstate.cards.sort(function sort(a: FlashCard, b: FlashCard){if (a.cardNumber < b.cardNumber) {return -1; }if (a.cardNumber > b.cardNumber) {return 1;}return 0;})\r\n            const onlyCharactersWithReviewValueAt0: FlashCard[] = sortedCharactersLowestToHighest.filter(eachContent => eachContent.repetitionValue === 0)\r\n            charsToAdd = onlyCharactersWithReviewValueAt0.slice(0,charactersToAdd).map(eachContent => {\r\n                const updatedContent: FlashCard = {...eachContent, repetitionValue: 1}\r\n                return updatedContent\r\n            })\r\n        }else {\r\n            //remove cards\r\n            const sortedCharactersHighestToLowest: FlashCard[] = characterSRSstate.cards.sort(function sortReverse(a: FlashCard, b: FlashCard){if (a.cardNumber > b.cardNumber) {return -1; }if (a.cardNumber < b.cardNumber) {return 1;}return 0;})\r\n            const charactersWithReviewValueAbove0ReverseSorted: FlashCard[] = sortedCharactersHighestToLowest.filter(eachContent => eachContent.repetitionValue > 0)\r\n            charsToAdd = charactersWithReviewValueAbove0ReverseSorted.slice(0,charactersToAdd).map(eachContent => {\r\n                const updatedContent: FlashCard = {...eachContent, repetitionValue: 0}\r\n                return updatedContent\r\n            })\r\n        }\r\n        return charsToAdd\r\n    }\r\n\r\n    const addOrRemoveCardsToPracticeFromList = (charactersToAdd: number[]): FlashCard[] => {\r\n        let charsToAdd: FlashCard[];\r\n        const sortedCharactersLowestToHighest: FlashCard[] = characterSRSstate.cards.sort(function sort(a: FlashCard, b: FlashCard){if (a.cardNumber < b.cardNumber) {return -1; }if (a.cardNumber > b.cardNumber) {return 1;}return 0;})\r\n        const onlyCharactersWithReviewValueAt0: FlashCard[] = sortedCharactersLowestToHighest.filter(eachContent => eachContent.repetitionValue === 0)\r\n        charsToAdd = onlyCharactersWithReviewValueAt0.filter(x => charactersToAdd.includes(x.cardNumber))\r\n\r\n        let charsToAddUpdated = charsToAdd.map(eachContent => {\r\n            const updatedContent: FlashCard = {...eachContent, repetitionValue: 1}\r\n            return updatedContent\r\n        })\r\n        return charsToAddUpdated\r\n    }\r\n\r\n    const getNewFinalCharValue = (charactersToAdd: number): number => {\r\n        const sortedCharactersLowestToHighest: FlashCard[] = characterSRSstate.cards.sort(function sort(a: FlashCard, b: FlashCard){if (a.cardNumber < b.cardNumber) {return -1; }if (a.cardNumber > b.cardNumber) {return 1;}return 0;})\r\n        const onlyCharactersWithReviewValueAt0: FlashCard[] = sortedCharactersLowestToHighest.filter(eachContent => eachContent.repetitionValue === 0)\r\n        const charsToAdd: FlashCard[] = onlyCharactersWithReviewValueAt0.slice(0,charactersToAdd)\r\n        const sortedCharsReviewValueAbove0WithNewChars: FlashCard[] = sortedCharactersLowestToHighest.filter(eachContent => eachContent.repetitionValue > 0).concat(charsToAdd)\r\n        const sortetReverse: FlashCard[] = sortedCharsReviewValueAbove0WithNewChars.sort(function sortReverse(a: FlashCard, b: FlashCard){if (a.cardNumber > b.cardNumber) {return -1; }if (a.cardNumber < b.cardNumber) {return 1;}return 0;})\r\n        return sortetReverse[0] ? sortetReverse[0].cardNumber : 0\r\n    }\r\n\r\n    const deleteANumberOfCharacters = () => {\r\n        const charactersYouWantToAdd: number = Number(addMoreCharactersTextField) ? Number(addMoreCharactersTextField) : 0\r\n        const charactersToDelete: FlashCard[] = addOrRemoveCardsToPractice(charactersYouWantToAdd, false)\r\n        setAddMoreCharactersTextField(\"\")\r\n        editListItemInBulk(charactersToDelete, characterSRSstate)\r\n    }\r\n\r\n    const addANumberOfCharacters = () => {\r\n        if (!isNaN(Number(addMoreCharactersTextField))) {\r\n            const charactersYouWantToAdd: number = Number(addMoreCharactersTextField) ? Number(addMoreCharactersTextField) : 0\r\n            const newCharactersToBeAdded: FlashCard[] = addOrRemoveCardsToPractice(charactersYouWantToAdd, true)\r\n            setAddMoreCharactersTextField(\"\")\r\n            editListItemInBulk(newCharactersToBeAdded, characterSRSstate)\r\n        } else {\r\n            const numberli = parseNumberList(addMoreCharactersTextField)\r\n            if (numberli.length > 0) {\r\n                const newCharactersToBeAdded: FlashCard[] = addOrRemoveCardsToPracticeFromList(numberli)\r\n                setAddMoreCharactersTextField(\"\")\r\n                editListItemInBulk(newCharactersToBeAdded, characterSRSstate)\r\n            } else {\r\n                setAddMoreCharactersTextField(\"no nums in list\")\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    const parseNumberList = (input: string): number[] => {\r\n        return (\r\n            input\r\n                .split(\",\") // Split the string by commas\r\n                .filter(value => value.trim() !== \"\") // Remove empty strings and whitespace\r\n                .map(Number) // Convert each remaining string to a number\r\n                .filter(Number.isFinite) // Ensure the result contains only valid numbers\r\n        );\r\n    };\r\n\r\n    const changeOnNewCharacterInputField = (e: React.FormEvent<HTMLInputElement>) => {\r\n        setAddMoreCharactersTextField(e.currentTarget.value)\r\n    }\r\n\r\n    const handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {\r\n        const spaceOrRightArrow: boolean = event.key.toString() === ' '\r\n            || event.key.toString() === \"ArrowRight\"\r\n            || event.key.toString() === '‘'\r\n            || event.key.toString() === '`'\r\n\r\n        //if the use wants to test themselves by writing the backside of the card\r\n        if (spaceOrRightArrow\r\n                && currentContent\r\n                && addMoreCharactersTextField\r\n                && addMoreCharactersTextField != \" \"\r\n                && currentContent.backSide.indexOf(addMoreCharactersTextField.trim()) > -1) {\r\n            setAddMoreCharactersTextField(\"\")\r\n            increaseReviewValueWithOne()\r\n        }else if (spaceOrRightArrow) {\r\n            //mark the card correct\r\n            setAddMoreCharactersTextField(\"\")\r\n            if (showCharacterSRSContentElement) {\r\n                increaseReviewValueWithOne()\r\n            }else {\r\n                setShowCharacterSRSContentElementFunc()\r\n            }\r\n        }else if(event.key.toString() === \"ArrowLeft\"){\r\n            //mark the card incorrect\r\n            setAddMoreCharactersTextField(\"\")\r\n            if (showCharacterSRSContentElement) {\r\n                decreaseReviewValueWithOne()\r\n            }else {\r\n                setShowCharacterSRSContentElementFunc()\r\n            }\r\n        }\r\n    };\r\n\r\n    const addCharactersPageContent = (): ReactElement => {\r\n        return <section>\r\n            <button type=\"button\" onClick={addANumberOfCharacters}>addNewChars</button>\r\n            <input\r\n                ref={addCharactersReference}\r\n                type=\"text\"\r\n                onKeyDown={handleKeyDown}\r\n                value={addMoreCharactersTextField} id=\"addMoreCharacters\"\r\n                placeholder=\"addCharacters\"\r\n                onInput={changeOnNewCharacterInputField}\r\n                autoComplete=\"off\">\r\n            </input>\r\n            <button type=\"button\" onClick={deleteANumberOfCharacters}>deleteLatestCharacters</button>\r\n        </section>\r\n    }\r\n\r\n    const setShowCharacterSRSContentElementFunc = () => {\r\n        setShowCharacterSRSContentElement(true);\r\n    }\r\n    const increaseReviewValueWithFive = () => {\r\n        respondToAPresentedCharacterSRSObject(5)\r\n    }\r\n    const increaseReviewValueWithOne = () => {\r\n        respondToAPresentedCharacterSRSObject(1)\r\n    }\r\n    const decreaseReviewValueWithFive = () => {\r\n        respondToAPresentedCharacterSRSObject(-5)\r\n    }\r\n    const decreaseReviewValueWithOne = () => {\r\n        respondToAPresentedCharacterSRSObject(-1)\r\n    }\r\n\r\n    const respondToAPresentedCharacterSRSObject = (increaseOrDecreaseReviewValue: number) => {\r\n        const current: FlashCard = currentContent\r\n        const updatedDate: string = new Date().toISOString().slice(0,10)\r\n        const updatedReviewValue: number =\r\n            (current && current.repetitionValue && current.repetitionValue+increaseOrDecreaseReviewValue > 0)\r\n                ? current.repetitionValue+increaseOrDecreaseReviewValue : 1\r\n        const updatedContent: FlashCard =\r\n            {...current,\r\n                repetitionValue: updatedReviewValue,\r\n                dateOfLastReview: updatedDate,\r\n                repetitionHistory: generateRepetitionHistoryOfLength30(current.repetitionHistory, increaseOrDecreaseReviewValue)\r\n            }\r\n        const updatedCharacterSRS: FlashCardDeck = {...characterSRSstate}\r\n        setShowCharacterSRSContentElement(false)\r\n        if (increaseOrDecreaseReviewValue > 0) {\r\n            addToPreviousCharacters(current, previousCharactersState)\r\n        }else if (increaseOrDecreaseReviewValue < 0) {\r\n            substractFromPreviousCharacters(current, previousCharactersState)\r\n        }\r\n        editListItemInBulk([updatedContent], updatedCharacterSRS)\r\n    }\r\n\r\n    const generateRepetitionHistoryOfLength30 = (oldHistory: number[], increaseOrDecrease: number): number[] => {\r\n        const basicHistory: number[] = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]\r\n        if (oldHistory == null ||\r\n            oldHistory == undefined ||\r\n            oldHistory.length < 30 ||\r\n            oldHistory.length > 30) {\r\n            return basicHistory\r\n        }else {\r\n            if (increaseOrDecrease > 0) {\r\n                const removeLast: number[] = oldHistory.slice(0,oldHistory.length-1)\r\n                const updatedList: number[] = [1].concat(removeLast)\r\n                return updatedList\r\n            }else if (increaseOrDecrease < 0) {\r\n                const removeLast: number[] = oldHistory.slice(0,oldHistory.length-1)\r\n                const updatedList: number[] = [0].concat(removeLast)\r\n                return updatedList\r\n            }else {\r\n                return oldHistory\r\n            }\r\n        }\r\n    }\r\n\r\n    const buttonsToShowAndHandleCharacterSRSContentElement = (): ReactElement => {\r\n        let buttonsToReturn: ReactElement;\r\n        if (!showCharacterSRSContentElement) {\r\n            buttonsToReturn =  <section>\r\n                <button type=\"button\" onClick={setShowCharacterSRSContentElementFunc}>showCharacter</button>\r\n            </section>\r\n        }else {\r\n            buttonsToReturn = <section>\r\n                <button id=\"decreaseByFive\" type=\"button\" onClick={decreaseReviewValueWithFive}>reviewValue-5</button>\r\n                <button id=\"decreaseByOne\" type=\"button\" onClick={decreaseReviewValueWithOne}>reviewValue-1</button>\r\n                <button id=\"increaseByOne\" type=\"button\" onClick={increaseReviewValueWithOne}>reviewValue+1</button>\r\n                <button id=\"increaseByOne\" type=\"button\" onClick={increaseReviewValueWithFive}>reviewValue+5</button>\r\n            </section>\r\n        }\r\n        return buttonsToReturn\r\n    }\r\n\r\n    const displayMostRecentCharacters = (listToDisplay: [FlashCard[], FlashCard[], FlashCard[]]): ReactElement => {\r\n        const mostRecentCharacter: FlashCard[] = listToDisplay[2] ? listToDisplay[2] : []\r\n        let resultString: string;\r\n        if (!mostRecentCharacter || mostRecentCharacter.length === 0) {\r\n            resultString = \"No previous characters yet\"\r\n        }else {\r\n            const shortList: FlashCard[] = mostRecentCharacter.length<5 ? mostRecentCharacter.reverse() : mostRecentCharacter.reverse().slice(0,5)\r\n            const stringList: string = shortList.map(each => each.backSide+each.cardNumber).join()\r\n            const netRepetition: number = mostRecentCharacter.length - (2 * listToDisplay[1].length)\r\n            resultString = \"previous: \" + stringList +\r\n                \" total: \" + mostRecentCharacter.length +\r\n                \" pos: \" + listToDisplay[0].length +\r\n                \" neg: \" + listToDisplay[1].length +\r\n                \" netRepetitions: \" + netRepetition\r\n        }\r\n\r\n        const buttonsToEditRecentChars: ReactElement =\r\n            <section>\r\n                <button id=\"increaseLastCardByOne\" type=\"button\" onClick={increaseRepetitionOfLastCharacterByOne}>increaseLastCardByOne</button>\r\n                {displayMostRecentCard()}\r\n                <button id=\"decreaseLastCardByOne\" type=\"button\" onClick={reduceRepetitionOfLastCharacterByOne}>reduceLastCardByOne</button>\r\n                <button id=\"togglePreviusCard\" type=\"button\" onClick={toggleShowPreviousCard}>toggleShowPrevious</button>\r\n            </section>\r\n        return <section>{resultString} {buttonsToEditRecentChars}</section>\r\n    }\r\n\r\n    const toggleShowPreviousCard = () => {\r\n        if (showPreviusCard) {\r\n            setShowPreviusCard(false)\r\n        }else {\r\n            setShowPreviusCard(true)\r\n        }\r\n    }\r\n\r\n    const increaseRepetitionOfLastCharacterByOne = () => {\r\n        editRepetitionOfLastCharacterByOne(1)\r\n    }\r\n\r\n    const reduceRepetitionOfLastCharacterByOne = () => {\r\n        editRepetitionOfLastCharacterByOne(-1)\r\n    }\r\n\r\n    const editRepetitionOfLastCharacterByOne = (integerToAdd: number) => {\r\n        const mostRecentCharactersList: FlashCard[] = previousCharactersState[2] ? previousCharactersState[2] : []\r\n        if (mostRecentCharactersList && mostRecentCharactersList.length > 0){\r\n            const recentCharNumber: number = mostRecentCharactersList[mostRecentCharactersList.length-1].cardNumber\r\n            const recentChar: FlashCard = characterSRSstate.cards.filter(eachCard => eachCard.cardNumber == recentCharNumber)[0]\r\n            const recentCharReviewnumberReduced: number = recentChar.repetitionValue+integerToAdd\r\n            if (recentCharReviewnumberReduced > 0) {\r\n                const updatedCharacterSRS: FlashCardDeck = {...characterSRSstate}\r\n                const updatedChar: FlashCard = {...recentChar, repetitionValue: recentCharReviewnumberReduced}\r\n                editListItemInBulk([updatedChar], updatedCharacterSRS)\r\n            }\r\n        }\r\n    }\r\n\r\n    const displayMostRecentCard = (): string => {\r\n        const desiredCard: FlashCard = getMostRecentCard()\r\n        if (desiredCard.cardNumber > 0) {\r\n            const returnString: string = desiredCard.repetitionValue + desiredCard.backSide + desiredCard.cardNumber\r\n            return returnString\r\n        }\r\n        return \"no cards to display\"\r\n    }\r\n\r\n    const getMostRecentCard = (): FlashCard => {\r\n        const mostRecentCharactersList: FlashCard[] = previousCharactersState[2] ? previousCharactersState[2] : []\r\n        if (mostRecentCharactersList && mostRecentCharactersList.length > 0){\r\n            const recentChar: FlashCard = mostRecentCharactersList[0]\r\n            const recentNumber: number = recentChar.cardNumber\r\n            const cardDeck: FlashCard[] = characterSRSstate.cards.filter(eachCard => eachCard.cardNumber == recentNumber)\r\n            if (cardDeck.length > 0) {\r\n                const desiredCard: FlashCard = cardDeck[0]\r\n                return desiredCard\r\n            }\r\n        }\r\n        return {... characterSRSstate.cards[0], cardNumber: 0}\r\n    }\r\n\r\n    const changeShowPrimaryInformationValue = () => {\r\n        const currentValue: boolean = cardDisplayLocalState.showPrimaryCardInfo\r\n        const updatedValue: CardDisplay = {...cardDisplayLocalState, showPrimaryCardInfo: !currentValue}\r\n        cardDisplayChangeState(updatedValue, cardDisplayLocalState)\r\n    }\r\n\r\n    const changeShowSecondaryInformationValue = () => {\r\n        const currentValue: boolean = cardDisplayLocalState.showSecondaryCardInfo\r\n        const updatedValue: CardDisplay = {...cardDisplayLocalState, showSecondaryCardInfo: !currentValue}\r\n        cardDisplayChangeState(updatedValue, cardDisplayLocalState)\r\n    }\r\n\r\n    const changeReadAloud = () => {\r\n        const currentValue: boolean = cardDisplayLocalState.readAloud\r\n        const updatedValue: CardDisplay = {...cardDisplayLocalState, readAloud: !currentValue}\r\n        cardDisplayChangeState(updatedValue, cardDisplayLocalState)\r\n    }\r\n\r\n    const showInfoButtons = (): ReactElement => {\r\n        return <section>\r\n            <button type=\"button\"\r\n                    onClick={changeShowPrimaryInformationValue}>showPrimary:{cardDisplayLocalState.showPrimaryCardInfo.toString()}</button>\r\n            <button type=\"button\"\r\n                    onClick={changeShowSecondaryInformationValue}>showSecondary:{cardDisplayLocalState.showSecondaryCardInfo.toString()}</button>\r\n            <button type=\"button\"\r\n                    onClick={changeReadAloud}>readAloud:{cardDisplayLocalState.readAloud.toString()}</button>\r\n        </section>\r\n    }\r\n\r\n    return <section>\r\n        <h1> Practice </h1>\r\n        {displayMostRecentCharacters(previousCharactersState)}\r\n        {displayNumberOfCharacters()}\r\n        {addCharactersPageContent()}\r\n        {showInfoButtons()}\r\n\r\n        {buttonsToShowAndHandleCharacterSRSContentElement()}\r\n        <div className={showPreviusCard ? \"side-by-side-container\" : \"\"}>\r\n            {todoPageContent()}\r\n            {showPreviusCharacter(previousCard.current, showPreviusCard.valueOf())}\r\n        </div>\r\n\r\n    </section>\r\n};\r\n\r\nexport default Practice;","\r\nimport {PropsWithChildren} from \"react\";\r\nimport {useDispatch, useSelector} from \"react-redux\";\r\nimport {bindActionCreators} from \"redux\";\r\nimport { characterSRSactionCreators, State } from '../state/index';\r\nimport FlashCardStateManipulation from \"../applogic/FlashcardDisplayLogic/FlashCardStateManipulation\";\r\n\r\nconst DisplayTagItem: React.FC<{TagItem: string[]}> =\r\n    (props: PropsWithChildren<{TagItem: string[]}>) => {\r\n\r\n        const dispatch = useDispatch();\r\n        const {editSingleTag} = bindActionCreators(characterSRSactionCreators, dispatch)\r\n        const characterSRSstate = useSelector(\r\n        (state: State) => state.characterSRS\r\n        )\r\n\r\n        var tempTagTitle: string = props.TagItem[0]\r\n        var tempTagBody: string = props.TagItem[1]\r\n\r\n        function detectOverlapWithOtherTags(cleanTitle: string, oldTagTitle: string, tags: Record<string, string>) {\r\n            var overlapWithOtherTags: boolean = false\r\n            const previousTagKeys: string[] = Object.keys(tags)\r\n            for (let eachKeyIndex in previousTagKeys) {\r\n                const eachKey: string = previousTagKeys[eachKeyIndex]\r\n                if ((eachKey != oldTagTitle) && (cleanTitle === eachKey)) {\r\n                    overlapWithOtherTags = true\r\n                }\r\n            }\r\n            return overlapWithOtherTags;\r\n        }\r\n\r\n        const saveEdit = () => {\r\n            var changesMade: boolean = false\r\n            if (!(tempTagTitle === props.TagItem[0])) {changesMade = true}\r\n            if (!(tempTagBody === props.TagItem[1])) {changesMade = true}\r\n            const cleanTitle: string = cleanTagTitle(tempTagTitle)\r\n            const oldTagTitle = props.TagItem[0]\r\n            const newTag: string[] = [cleanTitle, tempTagBody]\r\n            const overlapWithOtherTags: boolean = detectOverlapWithOtherTags(cleanTitle, oldTagTitle, characterSRSstate.tags)\r\n\r\n            if (changesMade && !overlapWithOtherTags && cleanTitle.length > 0) {\r\n              editSingleTag(newTag, oldTagTitle, characterSRSstate)\r\n            }else if (overlapWithOtherTags) {\r\n                console.log(\"error: the new tag name already exist\")\r\n            }\r\n        }\r\n\r\n        const cleanTagTitle = (input: string): string => {\r\n            if (input) {\r\n                return input.replace(/ /g,'').replace(/,/g, \"\").trim();\r\n            }\r\n            return \"\"\r\n        }\r\n\r\n        return <section>\r\n            <button type=\"button\" onClick={() => saveEdit()}>saveEditOn {props.TagItem[0]}</button>\r\n            <ul>\r\n                <li onInput={(e) =>\r\n                    tempTagTitle = FlashCardStateManipulation.editStringvalue(e, props.TagItem[0])}\r\n                    contentEditable=\"true\">{tempTagTitle}</li>\r\n                <li onInput={(e) =>\r\n                    tempTagBody = FlashCardStateManipulation.editStringvalue(e, props.TagItem[1])}\r\n                    contentEditable=\"true\">{tempTagBody}</li>\r\n            </ul>\r\n        </section>\r\n}\r\n\r\nexport default DisplayTagItem\r\n","import React, {PropsWithChildren, useState} from \"react\";\r\nimport {FlashCardDeck} from \"../interfaces/flashcarddeck\";\r\nimport DisplayTagItem from \"./DisplayTagItem\";\r\n\r\nconst DisplayTags: React.FC<{content: FlashCardDeck}> = (props: PropsWithChildren<{content: FlashCardDeck}>) => {\r\n\r\n    const getNestedArray = (tagMap: Record<string, string>): string[][] => {\r\n\r\n        let nestedElems: string[][] = new Array()\r\n        let allkeys: string[] = Object.keys(tagMap)\r\n        let allvalues: string[] = Object.values(tagMap)\r\n        var num:number = 0\r\n        for(num=0;num < allkeys.length;num++) {\r\n            const temparray: string[] = [allkeys[num], allvalues[num]]\r\n            nestedElems.push(temparray)\r\n        }\r\n        return nestedElems\r\n    }\r\n\r\n    const sortNestedArrayTagsByTitleAlphabeticly = (input: string[][]): string[][] => {\r\n        var sortedTags: string[][] = input.sort((n1,n2) => {\r\n            if (n1 > n2) {\r\n                return 1;\r\n            }\r\n            if (n1 < n2) {\r\n                return -1;\r\n            }\r\n            return 0;\r\n        });\r\n        return sortedTags\r\n    }\r\n\r\n    const [nestedArrayTagsToDosplay, setNestedArrayTagsToDosplay] =\r\n        useState<string[][]>(sortNestedArrayTagsByTitleAlphabeticly(getNestedArray(props.content.tags)))\r\n\r\n    var currentTagListToDisplay: string[][] = nestedArrayTagsToDosplay\r\n    const [tagSubstringSearchField, setTagSubstringSearchField] = useState(\"\")\r\n    const handleChangeToTagsubstringSearchField = (e: React.FormEvent<HTMLInputElement>) => {setTagSubstringSearchField(e.currentTarget.value)}\r\n\r\n    const displayByChosenTitle = () => {\r\n        const stringToLookFor: string = tagSubstringSearchField//\"ball\"\r\n        const result: string[][] = currentTagListToDisplay.filter((eachTags) => {\r\n            return eachTags[0].toLowerCase().includes(stringToLookFor)\r\n        })\r\n        setNestedArrayTagsToDosplay(result)\r\n    }\r\n\r\n    const sortAllCharsAlphabetically = () => {\r\n        const resultArray: string[][] = sortNestedArrayTagsByTitleAlphabeticly(getNestedArray(props.content.tags))\r\n        setNestedArrayTagsToDosplay(resultArray)\r\n    }\r\n\r\n    const display: JSX.Element = <section>\r\n        <p>her er teksten</p>\r\n        <button type=\"button\" onClick={() => sortAllCharsAlphabetically()}>showAllTags</button>\r\n        <button type=\"button\" onClick={() => displayByChosenTitle()}>filterByTitleSubstring</button>\r\n        <input type=\"tagToRemove\" value={tagSubstringSearchField} onChange={handleChangeToTagsubstringSearchField} />\r\n        <ul>\r\n            {currentTagListToDisplay.map((eachMap: string[]) =>(\r\n                <DisplayTagItem TagItem={eachMap}/>\r\n            ))}\r\n        </ul>\r\n    </section>\r\n\r\n    return display\r\n}\r\n\r\nexport default DisplayTags\r\n","import IPage from \"../interfaces/page\";\r\nimport {useDispatch, useSelector} from \"react-redux\";\r\nimport DisplayTags from \"../components/DisplayTags\";\r\nimport {bindActionCreators} from \"redux\";\r\nimport {FlashCardDeck} from \"../interfaces/flashcarddeck\";\r\nimport { characterSRSactionCreators, State} from '../state/index';\r\nimport FlashCardStateManipulation from \"../applogic/FlashcardDisplayLogic/FlashCardStateManipulation\";\r\nimport React, {useState} from \"react\";\r\n\r\nconst Tags: React.FunctionComponent<IPage> = props => {\r\n\r\n    const dispatch = useDispatch();\r\n    const {addNewTag, removeTag} = bindActionCreators(characterSRSactionCreators, dispatch)\r\n    const characterSRSstate: FlashCardDeck = useSelector(\r\n        (state: State) => state.characterSRS\r\n    )\r\n    var tagTitle: string = \"\"\r\n    var tagBody: string = \"\"\r\n    const [displayTagsBoolean, setDisplayTagsBoolean] = useState<boolean>(true);\r\n    const [fname, setFname] = useState(\"\")\r\n    const handleChange = (e: React.FormEvent<HTMLInputElement>) => {    setFname(e.currentTarget.value)  }\r\n\r\n    const addToTagList = () => {\r\n        if (tagTitle) {\r\n            const cleanTagTittle: string = tagTitle.replace(/ /g,'').replace(/,/g, \"\").trim();\r\n            if (cleanTagTittle.length > 0) {\r\n                var currentDecktags = characterSRSstate.tags\r\n                let typeMap: Record<string, string> = {}\r\n\r\n                let mykeys: string[] = Array.from(Object.keys(currentDecktags))\r\n                let myvalues: string[] = Array.from(Object.values(currentDecktags))\r\n\r\n                var num:number = 0\r\n                for(num=0;num < mykeys.length;num++) {\r\n                    typeMap[mykeys[num]]  = myvalues[num]\r\n                }\r\n                typeMap[tagTitle] = tagBody;\r\n\r\n                addNewTag(typeMap, characterSRSstate)\r\n            }\r\n        }\r\n    }\r\n\r\n    const localRemoveTag = () => {\r\n        let tagTitle: string = fname\r\n        let currentDecktags: Record<string, string> = characterSRSstate.tags\r\n        let mykeys: string[] = Array.from(Object.keys(currentDecktags))\r\n        let myvalues: string[] = Array.from(Object.values(currentDecktags))\r\n        if (mykeys.includes(tagTitle)) {\r\n            let index: number = mykeys.indexOf(tagTitle)\r\n            let relevantvalue = myvalues[index]\r\n            let newKeys: string[] = mykeys.filter(x=>x !== tagTitle)\r\n            let newValues: string[] = myvalues.filter(x=> x !== relevantvalue)\r\n\r\n            let typeMap: Record<string, string> = {}\r\n            var num:number = 0\r\n            for(num=0;num < newKeys.length;num++) {\r\n                typeMap[newKeys[num]]  = newValues[num]\r\n            }\r\n            removeTag(typeMap, characterSRSstate)\r\n        }\r\n    }\r\n\r\n    const displayTags = (deckState: FlashCardDeck, showState: boolean) => {\r\n        if (showState) {\r\n            return <section>\r\n                <DisplayTags content={deckState}/>\r\n            </section>\r\n        }else {\r\n            return <section><p>No tags shown</p></section>\r\n        }\r\n    }\r\n\r\n    const toggleDisplayTags = () => {\r\n        setDisplayTagsBoolean(!displayTagsBoolean)\r\n    }\r\n\r\n    return (\r\n    <section>\r\n        <h1> Tags </h1>\r\n        <button id=\"createtags\" type=\"button\" onClick={addToTagList}>createNewTag</button>\r\n        <button id=\"showtags\" type=\"button\" onClick={toggleDisplayTags}>displaytags:{displayTagsBoolean.valueOf()}</button>\r\n        <button id=\"removeTag\" type=\"button\" onClick={localRemoveTag}>removeTag:{fname.valueOf()}</button>\r\n        <input type=\"tagToRemove\" value={fname} onChange={handleChange} />\r\n        <ul>\r\n            <li onInput={(e) =>\r\n                tagTitle = FlashCardStateManipulation.editStringvalue(e, \"tagTitle\")}\r\n                contentEditable=\"true\">\r\n                \"tagTitle\"</li>\r\n            <li onInput={(e) =>\r\n                tagBody = FlashCardStateManipulation.editStringvalue(e, \"tagBody\")}\r\n                contentEditable=\"true\">\r\n                \"tagBody\"</li>\r\n        </ul>\r\n        {displayTags(characterSRSstate, displayTagsBoolean)}\r\n    </section>\r\n    );\r\n};\r\n\r\nexport default Tags;","import React, { useState } from \"react\";\r\nimport { FilePond } from \"react-filepond\";\r\nimport \"filepond/dist/filepond.min.css\";\r\n\r\n\r\ninterface FileInputProps {\r\n    onContentChange: (content: string) => void;\r\n}\r\n\r\nconst FileInputMainDeck =  ({ onContentChange }: FileInputProps) => {\r\n    // Using 'any' type to avoid TypeScript errors\r\n    const [files, setFiles] = useState<any[]>([]);\r\n    const [content, setContent] = useState(\"\");\r\n\r\n    const handleInit = () => {\r\n        console.log('FilePond instance has initialised');\r\n    }\r\n\r\n    return (\r\n        <div className=\"App\">\r\n            <FilePond\r\n                files={files}\r\n                oninit={handleInit}\r\n                allowMultiple={false}\r\n                acceptedFileTypes={['text/plain']}\r\n                onaddfile={(error, fileItem) => {\r\n                    const file = fileItem.file;\r\n                    const reader = new FileReader();\r\n\r\n                    reader.onload = (e) => {\r\n                        const content = e.target?.result as string || '';\r\n                        onContentChange(content);\r\n                    };\r\n\r\n                    reader.readAsText(file);\r\n                }}\r\n                onupdatefiles={fileItems => {\r\n                    setFiles(fileItems.map(fileItem => fileItem.file));\r\n                }}\r\n            />\r\n            <div>{content}</div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default FileInputMainDeck;\r\n","import React, {useState} from \"react\";\r\nimport IPage from \"../interfaces/page\";\r\nimport {FlashCardDeck} from \"../interfaces/flashcarddeck\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport {bindActionCreators} from \"redux\";\r\nimport { characterSRSactionCreators, State } from '../state/index';\r\nimport FileInputMainDeck from '../components/FileInputMainDeck';\r\n\r\nfunction clearMergeInputField() {\r\n    (document.getElementById(\"deckToMerge\") as HTMLInputElement).value = \"\"\r\n}\r\n\r\nconst LoadAndSave: React.FunctionComponent<IPage> = props => {\r\n    const dispatch = useDispatch();\r\n    const {createSRSobject} = bindActionCreators(characterSRSactionCreators, dispatch)\r\n    const characterSRSstate = useSelector(\r\n        (state: State) => state.characterSRS\r\n    )\r\n\r\n    const handleContent = (fileContent: string) => {\r\n        let testLarge: FlashCardDeck = JSON.parse(fileContent);\r\n        createSRSobject(testLarge);\r\n    }\r\n\r\n    const saveAsJsonfile = (filename: string, text: string) => {\r\n        var element = document.createElement('a');\r\n        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\r\n        element.setAttribute('download', filename);\r\n        element.style.display = 'none';\r\n        document.body.appendChild(element);\r\n        element.click();\r\n        document.body.removeChild(element);\r\n    }\r\n\r\n    const downloadCharacterSRSobject = () => {\r\n        const characterSRSobject: FlashCardDeck = characterSRSstate\r\n        const result: string = JSON.stringify(characterSRSobject)\r\n        saveAsJsonfile(\"updatedList.json\", result)\r\n    }\r\n\r\n    const getCharactersJson = (filename: string, url: string) => {\r\n        fetch(url)\r\n            .then(res => res.json())\r\n            .then(data => saveAsJsonfile(filename, JSON.stringify(data)))\r\n    }\r\n\r\n    return <section>\r\n        <h1>Load and download flashcard files</h1>\r\n        <FileInputMainDeck onContentChange={handleContent}/>\r\n\r\n        <button type=\"button\" onClick={() => downloadCharacterSRSobject()}>download changes</button>\r\n        <p>{characterSRSstate.cards.length}</p>\r\n\r\n        <p>******** Heisig character example decks that can be download (keywords has to be added by the user) **********</p>\r\n        <button type=\"button\" onClick={() => getCharactersJson(\r\n            \"heisigKanjiV5-3030noKeys.json\",\r\n            \"https://weiqifan1.github.io/hanzimining_data/heisigKanjiV5-3030noKeys.json\")}>\r\n            heisigKanjiV5-3030noKeys</button>\r\n        <button type=\"button\" onClick={() => getCharactersJson(\r\n            \"heisigTraditionalV1-3035noKeys.json\",\r\n            \"https://weiqifan1.github.io/hanzimining_data/heisigTraditionalV1-3035noKeys.json\")}>\r\n            heisigTraditionalV1-3035noKeys</button>\r\n        <button type=\"button\" onClick={() => getCharactersJson(\r\n            \"heisigSimplifiedV1-3018noKeys.json\",\r\n            \"https://weiqifan1.github.io/hanzimining_data/heisigSimplifiedV1-3018noKeys.json\")}>\r\n            heisigSimplifiedV1-3018noKeys</button>\r\n    </section>\r\n};\r\n\r\nexport default LoadAndSave;","import {FlashCardDeck} from \"../../interfaces/flashcarddeck\";\r\nimport {FlashCard} from \"../../interfaces/flashcard\";\r\nimport {mapkeys} from \"../flashcardHelperFunctions/gettingFlashCards\";\r\n\r\nfunction doGenerateCards(remainingRawText: string): string[][] {\r\n    const maxUserSetFields = 7 //the user might set any of 8 fields\r\n    var lookForNewLine = false\r\n    var previousLineIsCurly = false\r\n    var lineLimit: number = maxUserSetFields\r\n    var lineIsCurly: boolean = false\r\n    var currentStr: string = \"\"\r\n    var currentCard: string[] = []\r\n    var currentDeck: string[][] = []\r\n    for (var i = 0; i < remainingRawText.length-1; i++) {\r\n        if (currentDeck.length == 3 && currentCard.length == 0) {\r\n            const stophere = \"\"\r\n        }\r\n        const currentChar = remainingRawText.charAt(i)\r\n        const nextChar = remainingRawText.charAt(i+1)\r\n        if (i == remainingRawText.length-2) {\r\n            currentStr = currentStr + currentChar + nextChar\r\n            currentCard.push(currentStr)\r\n            currentDeck.push(currentCard)\r\n            lookForNewLine = true\r\n        }else if (currentCard.length == lineLimit) {\r\n            currentDeck.push(currentCard)\r\n            lookForNewLine = true\r\n            currentCard = []\r\n            currentStr = ''\r\n            lineIsCurly = false\r\n            //lineLimit = 8\r\n        }\r\n        if (lineIsCurly == false && currentChar == '\\n' && previousLineIsCurly) {\r\n            currentStr = \"\"\r\n            previousLineIsCurly = false\r\n        }else if (lineIsCurly == false && currentChar == '\\n' && nextChar == '\\n' && !(currentStr == \"\")) {\r\n            lookForNewLine = true\r\n            currentCard.push(currentStr)\r\n            currentDeck.push(currentCard)\r\n            currentCard = []\r\n            currentStr = \"\"\r\n        }else if (lineIsCurly == false && currentChar == '\\n' && nextChar == '\\n') {\r\n            lookForNewLine = true\r\n        }else if (lineIsCurly == false && !lookForNewLine && currentChar == '\\n' && currentCard.length == lineLimit) {\r\n            currentDeck.push(currentCard)\r\n            currentCard = []\r\n            lookForNewLine = true\r\n        }else if (lineIsCurly == false && !lookForNewLine && currentChar == '\\n' ) {\r\n            currentCard.push(currentStr)\r\n            currentStr = \"\"\r\n            previousLineIsCurly = false\r\n        }else if (currentStr.length == 0 && currentChar == '{') {\r\n            lineIsCurly = true\r\n            lookForNewLine = false\r\n            //lineLimit = lineLimit + 1\r\n        }else if (lineIsCurly == true && !lookForNewLine && currentChar == '}') {\r\n            currentCard.push(currentStr)\r\n            currentStr = \"\"\r\n            lineIsCurly = false\r\n            previousLineIsCurly = true\r\n        }else if (!lookForNewLine) {\r\n            currentStr = currentStr + currentChar\r\n        }else {\r\n            currentStr = currentStr\r\n            lookForNewLine = false\r\n        }\r\n    }\r\n    return currentDeck\r\n}\r\n\r\nfunction stringToListSplitBySpace(input: string): string[] {\r\n    const result: string[] = input.trim().split(/\\s+/)\r\n    return result;\r\n}\r\n\r\nfunction stringToNumbersSplitBySpace(input: string, numberOfCards: number[]): number[] {\r\n    const firstresult: string[] = stringToListSplitBySpace(input)\r\n    const numbers: number[] = firstresult.filter(each => !isNaN(Number(each))).map(e => Number(e)).filter(ea => numberOfCards.includes(ea))\r\n    return numbers;\r\n}\r\n\r\nfunction arrayToCard(each: string[], numberOfCards: number) {\r\n    const numberRange: number[] = Array.from(Array(numberOfCards).keys()).map(x => x + 1)\r\n    const cardName: string = each.length > 0 ? each[0] : \"\"\r\n    const frontSide: string = each.length > 1 ? each[1] : \"\"\r\n    const backSide: string = each.length > 2 ? each[2] : \"\"\r\n    const primaryInfo: string = each.length > 3 ? each[3] : \"\"\r\n    const secondaryInfo: string = each.length > 4 ? each[4] : \"\"\r\n    const notable: number[] = each.length > 5 ? stringToNumbersSplitBySpace(each[5], numberRange) : []\r\n    const tags: string[] = each.length > 6 ? stringToListSplitBySpace(each[6]) : []\r\n\r\n    const cards: FlashCard = {\r\n        cardNumber: 0,\r\n        cardName: cardName.trim(),\r\n        frontSide: frontSide.trim(),\r\n        backSide: backSide.trim(),\r\n        primaryInfo: primaryInfo.trim(),\r\n        secondaryInfo: secondaryInfo.trim(),\r\n        notableCards: notable,\r\n        dateOfLastReview: \"0001-01-01\",\r\n        repetitionValue: 0,\r\n        repetitionHistory: [],\r\n        tags: tags\r\n    }\r\n    return cards\r\n}\r\n\r\nfunction generateCards(rawText: string): FlashCard[] {\r\n    const result: string[][] = doGenerateCards(rawText)\r\n    const cardList: FlashCard[] = result.map(each => arrayToCard(each, result.length))\r\n    return cardList\r\n}\r\n\r\nfunction updateCardTags(allcards: FlashCard[], oldname: string, newname: string): FlashCard[] {\r\n    var updatedCards: FlashCard[] = []\r\n    for (let i = 0; i < allcards.length; i++) {\r\n        const currentcard: FlashCard = allcards[i]\r\n        const curretTagList: string[] = currentcard.tags\r\n        var updatedTags: string[] = []\r\n        for (let k = 0; k < curretTagList.length; k++) {\r\n            const currentTag: string = curretTagList[k]\r\n            if (currentTag == oldname) {\r\n                updatedTags.push(newname.trim())\r\n            } else {\r\n                updatedTags.push(currentTag)\r\n            }\r\n        }\r\n        const updatedCard: FlashCard = {...currentcard, tags: updatedTags}\r\n        updatedCards.push(updatedCard)\r\n    }\r\n    return updatedCards\r\n}\r\n\r\nfunction updateTagList(allTags: Record<string, string>, newname: string, newinfo: string, oldname: string, oldinfo: string): Record<string, string> {\r\n    var newtags: Record<string, string> = {}\r\n    const oldTagNames: string[] = mapkeys(allTags)\r\n    for (let i = 0; i < oldTagNames.length; i++) {\r\n        const oldTagName: string = oldTagNames[i]\r\n        const oldTagValue: string = allTags[oldTagName]\r\n        if (oldTagName == oldname) {\r\n            const updatedvalue: string = newinfo + \"\\n\" + oldTagValue\r\n            newtags[newname] = updatedvalue\r\n        }else {\r\n            newtags[oldTagName] = oldTagValue\r\n        }\r\n    }\r\n    return newtags;\r\n}\r\n\r\nexport function replaceDeckNameAndInfo(inputDeck: FlashCardDeck, newname: string, newinfo: string): FlashCardDeck {\r\n    const allcards: FlashCard[] = inputDeck.cards\r\n    const allTags: Record<string, string> = inputDeck.tags\r\n    const oldname: string = inputDeck.deckName\r\n    const oldinfo: string = inputDeck.deckInfo\r\n    const updatedCards: FlashCard[] = updateCardTags(allcards, oldname, newname);\r\n    const updatedTags: Record<string, string> = updateTagList(allTags, newname, newinfo, oldname, oldinfo)\r\n    const updatedDeck: FlashCardDeck = {...inputDeck, cards: updatedCards, tags: updatedTags, deckName: newname, deckInfo: newinfo}\r\n    return updatedDeck\r\n}\r\n\r\nexport function generateAllLinesDeck(rawText: string, deckName: string, deckInfo: string): FlashCardDeck {\r\n    //write a function that generate a deck based on tawText, deck name and deck info\r\n    const cards: FlashCard[] = generateCards(rawText)\r\n    var newtags: string[] = []\r\n    for (var numbercard in cards) {\r\n        const tagsfromcards: string[] = cards[numbercard].tags\r\n        newtags = newtags.concat(tagsfromcards)\r\n        //newtags. newtags.concat(cards[numbercard].tags)\r\n    }\r\n    //const tagNames = cards.map(each => newtags.concat(each.tags))//Array.from(new Set(cards.map(each => each.tags)))\r\n    const tags: Record<string, string> = {}\r\n    for (var name in newtags) {\r\n        const restag: string = newtags[name]\r\n        tags[restag] = restag\r\n    }\r\n    var updatedWithNums: FlashCard[] = []\r\n    for (var i = 0; i < cards.length; i++) {\r\n        const examp: FlashCard = cards[i]\r\n        const updatedCard: FlashCard = {...examp, cardNumber: i+1}\r\n        updatedWithNums.push(updatedCard)\r\n    }\r\n    const newFlash: FlashCardDeck = {\r\n        deckName: deckName.trim(),\r\n        deckInfo: deckInfo.trim(),\r\n        settings: {},\r\n        tags: tags,\r\n        cards: updatedWithNums\r\n    }\r\n    return newFlash\r\n}\r\n","import React, {ReactElement, useEffect, useRef, useState} from \"react\";\r\nimport IPage from \"../interfaces/page\";\r\nimport \"./EditCard.css\"\r\n\r\nimport {useDispatch, useSelector} from \"react-redux\";\r\nimport {bindActionCreators} from \"redux\";\r\nimport { characterSRSactionCreators,\r\n    State } from '../state/index';\r\nimport {FlashCardDeck} from \"../interfaces/flashcarddeck\";\r\nimport {FlashCard} from \"../interfaces/flashcard\";\r\nimport {replaceDeckNameAndInfo,\r\n} from \"../applogic/pageHelpers/createDeckHelper\";\r\n\r\nconst EditDeck: React.FunctionComponent<IPage> = props => {\r\n    const addCharactersReference = useRef<HTMLInputElement | null>(null);\r\n    useEffect(()=>{addCharactersReference.current?.focus();},[])\r\n    const dispatch = useDispatch();\r\n    //edit deck\r\n    const {createDeck} = bindActionCreators(characterSRSactionCreators, dispatch)\r\n    const {addNewCardsToDeck} = bindActionCreators(characterSRSactionCreators, dispatch)\r\n    //deleteOrEditCardOrder\r\n    const {deleteOrEditCardOrder} = bindActionCreators(characterSRSactionCreators, dispatch)\r\n    //create and read SRS\r\n    const {createSRSobject} = bindActionCreators(characterSRSactionCreators, dispatch)\r\n    const characterSRSstate: FlashCardDeck = useSelector(\r\n        (state: State) => state.characterSRS\r\n    )\r\n    //create deck\r\n    const [localdeckName, setLocaldeckName] = useState<string>(\"\")\r\n    const [localdeckInfo, setLocaldeckInfo] = useState<string>(\"\")\r\n\r\n    //delete or edit card\r\n    const [localdeleteCards, setLocaldeleteCards] = useState<string>(\"\")\r\n    const [localeditCards, setLocaleditCards] = useState<string>(\"\")\r\n\r\n    //create new card\r\n    const [localcardNumber, setLocalcardNumber] = useState<number>(characterSRSstate.cards.length + 1)\r\n    const [localcardName, setLocalcardName] = useState<string>(\"\")\r\n    const [localfrontSide, setLocalfrontSide] = useState<string>(\"\")\r\n    const [localbackSide, setLocalbackSide] = useState<string>(\"\")\r\n    const [localprimaryInfo, setLocalprimaryInfo] = useState<string>(\"\")\r\n    const [localsecondaryInfo, setLocalsecondaryInfo] = useState<string>(\"\")\r\n    const [localnotableCards, setLocalnotableCards] = useState<string>(\"\")\r\n    const [localtags, setLocaltags] = useState<string>(\"\")\r\n\r\n    function editAndDeleteCardsButtonFunc() {\r\n        const deleteInput: string = localdeleteCards\r\n        const editInput: string = localeditCards\r\n        if (deleteInput.trim().length == 0 && editInput.trim().length > 0) {\r\n            deleteOrEditCardOrder(\"\", editInput, characterSRSstate)\r\n        }else if (editInput.trim().length == 0 && deleteInput.trim().length > 0) {\r\n            deleteOrEditCardOrder(deleteInput, \"\", characterSRSstate)\r\n        }\r\n    }\r\n\r\n    function createDeckGetData() {\r\n        const newdeck: FlashCardDeck = {\r\n            deckName: localdeckName,\r\n            deckInfo: localdeckInfo,\r\n            settings: {},\r\n            tags: {},\r\n            cards: []\r\n        }\r\n        createDeck([], newdeck)\r\n    }\r\n\r\n    function changeDeckNameAndInfo() {\r\n        const deck: FlashCardDeck = characterSRSstate\r\n        const card: FlashCard[] = deck.cards\r\n        const updatedDeck: FlashCardDeck = replaceDeckNameAndInfo(characterSRSstate, localdeckName, localdeckInfo)\r\n        createSRSobject(updatedDeck)\r\n    }\r\n\r\n    function addFormInputToDeck() {\r\n        const deck: FlashCardDeck = characterSRSstate\r\n\r\n        const newCard: FlashCard = {\r\n            cardNumber: localcardNumber,\r\n            cardName: localcardName,\r\n            frontSide: localfrontSide,\r\n            backSide: localbackSide,\r\n            primaryInfo: localprimaryInfo,\r\n            secondaryInfo: localsecondaryInfo,\r\n            notableCards: [],\r\n            dateOfLastReview: \"0001-01-01\",\r\n            repetitionValue: 0,\r\n            repetitionHistory: [],\r\n            tags: generateTags(localtags, deck)\r\n        }\r\n        addNewCardsToDeck([newCard], characterSRSstate)\r\n    }\r\n\r\n    function clearFormInputToDeck() {\r\n        setLocalcardNumber(characterSRSstate.cards.length + 1)\r\n        setLocalcardName(\"\")\r\n        setLocalfrontSide(\"\")\r\n        setLocalbackSide(\"\")\r\n        setLocalprimaryInfo(\"\")\r\n        setLocalsecondaryInfo(\"\")\r\n        setLocalnotableCards(\"\")\r\n        setLocaltags(\"\")\r\n    }\r\n\r\n    const generateTags = (input: string, deck: FlashCardDeck): string[] => {\r\n        const res: string[] = input.split(/(\\s+)/).map(each => each.trim())\r\n        //remove impossibleCards\r\n        const nestedCardTags: string[][] = deck.cards.map(each => each.tags)\r\n        const cardTags: string[] = nestedCardTags.reduce((accumulator, value) => accumulator.concat(value), [])\r\n        const deckTags: string[] = cardTags.concat(Object.keys(deck.tags))\r\n        const resWithoutImpossibleNums: string[] = res.filter(each => deckTags.indexOf(each) > -1)\r\n        return resWithoutImpossibleNums\r\n    }\r\n\r\n    const generateNotableCards = (input: string, deck: FlashCardDeck): number[] => {\r\n        const res: string[] = localnotableCards.split(/(\\s+)/).map(each => each.trim())\r\n        //remove impossibleCards\r\n        const resWithoutNonNums: number[] = res.filter(each => !isNaN(+each)).map(eachNum => +eachNum)\r\n        const deckCards: number[] = deck.cards.map(each => each.cardNumber)\r\n        const resWithoutImpossibleNums: number[] = resWithoutNonNums.filter(each => deckCards.indexOf(each) > -1)\r\n        return resWithoutImpossibleNums\r\n    }\r\n\r\n    const handleCardNumberChange = (e: React.ChangeEvent<HTMLInputElement>) => {\r\n        // No longer need to cast to any - hooray for react!\r\n        const newStr: string = e.target.value\r\n        const newNumber: number = +newStr\r\n        setLocalcardNumber(newNumber);\r\n    }\r\n\r\n    const createDeckReact = (): ReactElement => {\r\n        return <section className=\"create\">\r\n            <form>\r\n                <label>\r\n                    deckName:\r\n                    <input type=\"text\" name=\"deckName\" value={localdeckName} onChange={e => setLocaldeckName(e.currentTarget.value)}></input>\r\n                </label>\r\n                <label>\r\n                    deckInfo:\r\n                    <input type=\"text\" name=\"deckInfo\" value={localdeckInfo} onChange={e => setLocaldeckInfo(e.currentTarget.value)}></input>\r\n                </label>\r\n            </form>\r\n            <button type=\"button\" onClick={\r\n                () => createDeckGetData() }>\r\n                {\"create deck\"}</button>\r\n            <button type=\"button\" onClick={\r\n                () => changeDeckNameAndInfo() }>\r\n                {\"change deck name and info\"}</button>\r\n        </section>\r\n    }\r\n\r\n    const editAndDeleteCards = (): ReactElement => {\r\n        return <section className=\"create\">\r\n            <form>\r\n                <label>\r\n                    deleteCards:\r\n                    <input type=\"text\" name=\"deleteCards\" value={localdeleteCards} onChange={deleteCardsOnChange}></input>\r\n                </label>\r\n                <label>\r\n                    editCards:\r\n                    <input type=\"text\" name=\"editCards\" value={localeditCards} onChange={editCardsOnChange}></input>\r\n                </label>\r\n            </form>\r\n            <button type=\"button\" onClick={\r\n                () => editAndDeleteCardsButtonFunc() }>\r\n                {\"delete or edit cards\"}</button>\r\n        </section>\r\n    }\r\n\r\n    function deleteCardsOnChange(e: React.ChangeEvent<HTMLInputElement>) {\r\n        setLocaleditCards(\"\")\r\n        setLocaldeleteCards(e.currentTarget.value)\r\n    }\r\n\r\n    function editCardsOnChange(e: React.ChangeEvent<HTMLInputElement>) {\r\n        setLocaldeleteCards(\"\")\r\n        setLocaleditCards(e.currentTarget.value)\r\n    }\r\n\r\n    const newCardFrom = (): ReactElement => {\r\n\r\n        return <section className=\"create\">\r\n            <form >\r\n                <label>\r\n                    cardNumber:\r\n                    <input type=\"number\" name=\"cardNumber\" value={localcardNumber} onChange={handleCardNumberChange}></input>\r\n                </label>\r\n                <label>\r\n                    cardName:\r\n                    <input type=\"text\" name=\"cardName\" value={localcardName} onChange={e => setLocalcardName(e.currentTarget.value)}></input>\r\n                </label>\r\n                <label>\r\n                    frontSide:\r\n                    <input type=\"text\" name=\"frontSide\" value={localfrontSide} onChange={e => setLocalfrontSide(e.currentTarget.value)}></input>\r\n                </label>\r\n                <label>\r\n                    backSide:\r\n                    <input type=\"text\" name=\"backSide\" value={localbackSide} onChange={e => setLocalbackSide(e.currentTarget.value)}></input>\r\n                </label>\r\n                <label>\r\n                    primaryInfo:\r\n                    <input type=\"text\" name=\"primaryInfo\" value={localprimaryInfo} onChange={e => setLocalprimaryInfo(e.currentTarget.value)}></input>\r\n                </label>\r\n                <label>\r\n                    secondaryInfo:\r\n                    <input type=\"text\" name=\"secondaryInfo\" value={localsecondaryInfo} onChange={e => setLocalsecondaryInfo(e.currentTarget.value)}></input>\r\n                </label>\r\n                <label>\r\n                    tags:\r\n                    <input type=\"text\" name=\"tags\" value={localtags} onChange={e => setLocaltags(e.currentTarget.value)}></input>\r\n                </label>\r\n            </form>\r\n            <button type=\"button\" onClick={\r\n                () => addFormInputToDeck() }>\r\n                {\"add card\"}</button>\r\n            <br/>\r\n            <br/>\r\n            <button type=\"button\" onClick={\r\n                () => clearFormInputToDeck() }>\r\n                {\"clear\"}</button>\r\n\r\n        </section>\r\n    }\r\n\r\n    return <section>\r\n        <h1>Create Deck</h1>\r\n        {createDeckReact()}\r\n        <h1>Delete or edit cards</h1>\r\n        {editAndDeleteCards()}\r\n        <h1>Add card</h1>\r\n        {newCardFrom()}\r\n    </section>\r\n};\r\n\r\nexport default EditDeck;","import React from \"react\";\r\nimport {FlashCard} from \"../interfaces/flashcard\";\r\nimport CardComponent from \"./CardComponent\";\r\nimport CardDisplay from \"../interfaces/cardDisplay\";\r\n\r\nconst CardListComponent: React.FC<{data: FlashCard[], cardDisplay: CardDisplay}> = (props) => {\r\n    return (\r\n        <ul>\r\n            {props.data.map((item) =>(\r\n                <CardComponent content={item}\r\n                               show={true}\r\n                               cardDisplay={props.cardDisplay} alwaysShow={false}/>\r\n            ))}\r\n        </ul>\r\n    )\r\n}\r\nexport default CardListComponent","import React, {PropsWithChildren, useState} from \"react\";\r\nimport {FlashCardDeck} from \"../interfaces/flashcarddeck\";\r\nimport DisplayTagItem from \"./DisplayTagItem\";\r\nimport CardComponent from \"./CardComponent\";\r\nimport AutoSuggest from \"react-autosuggest\";\r\nimport {isSortingValue, SortingValueAll} from \"../interfaces/types/sortingValue\";\r\n\r\nconst TagFilteringComponent: React.FC<{deckTagList: string[], content: Record<string, string>, setFunction: any, eachKey: number, eachValue: string}> =\r\n    (props) => {\r\n\r\n        const [suggestionsTagName, setSuggestionsTagName] = useState<string[]>([]);\r\n        const [suggestionsFilterValue, setSuggestionsFilterValue] = useState<string[]>(SortingValueAll);\r\n        const [tagName, setTagName] = useState<string>(\"\")\r\n        const [filterValue, setFilterValue] = useState<string>(\"\")\r\n\r\n        const removeTagFilteringComponent = () => {\r\n            const allKeys: number[] = Object.keys(props.content).map(each => parseInt(each))\r\n            var updatedList: string[] = [];\r\n            for (let i = 0; i < allKeys.length; i++) {\r\n                const currentK: number = allKeys[i]\r\n                if (currentK != props.eachKey) {\r\n                    const mystr: string = props.content[currentK]\r\n                    updatedList.push(mystr)\r\n                }\r\n            }\r\n\r\n            var updatedRecord: Record<string, string> = {}\r\n            for (let k = 0; k < updatedList.length; k++) {\r\n                const newnum: number = k +1\r\n                const text: string = updatedList[k]\r\n                updatedRecord[newnum.toString()] = text\r\n            }\r\n            props.setFunction(updatedRecord)\r\n        }\r\n\r\n        function handleNewFilteringValue() {\r\n            var listToUpdate: Record<string, string> = props.content\r\n            var newValue: string = SortingValueAll[0]\r\n            var valueToTest: string = filterValue\r\n            if (valueToTest != null && valueToTest.length > 0 && isSortingValue(valueToTest.toUpperCase())) {\r\n                newValue = valueToTest.toUpperCase()\r\n            }\r\n            setFilterValue(newValue)\r\n\r\n            var newName: string = \"\"\r\n            var nameToTest: string = tagName\r\n            if (nameToTest != null && nameToTest.length > 0 && props.deckTagList.includes(nameToTest)) {\r\n                newName = nameToTest\r\n            }\r\n            listToUpdate[props.eachKey.toString()] = newName + \" \" + newValue\r\n            setTagName(newName)\r\n            setFilterValue(newValue)\r\n            props.setFunction(listToUpdate)\r\n\r\n            setFilterValue(\"\")\r\n            setTagName(\"\")\r\n        }\r\n\r\n        const saveTagFilteringState = () => {\r\n            handleNewFilteringValue();\r\n        }\r\n\r\n        function getSuggestionsTagName(value: string): string[] {\r\n            return props.deckTagList.filter(language =>\r\n                language.startsWith(value.trim().toLowerCase())\r\n            );\r\n        }\r\n\r\n        const display: JSX.Element = <section>\r\n            <button type=\"button\" onClick={saveTagFilteringState}>save</button>\r\n\r\n            <AutoSuggest\r\n                suggestions={suggestionsTagName}\r\n                onSuggestionsClearRequested={() => setSuggestionsTagName([])}\r\n                onSuggestionsFetchRequested={({ value }) => {\r\n                    setTagName(value);\r\n                    setSuggestionsTagName(getSuggestionsTagName(value));\r\n                }}\r\n                onSuggestionSelected={(_, { suggestionValue }) =>\r\n                    console.log(\"Selected: \" + suggestionValue)\r\n                }\r\n                getSuggestionValue={suggestion => suggestion}\r\n                renderSuggestion={suggestion => <span>{suggestion}</span>}\r\n                inputProps={{\r\n                    placeholder: \"Type tag name\",\r\n                    value: tagName,\r\n                    onChange: (_, { newValue, method }) => {\r\n                        setTagName(newValue);\r\n                    }\r\n                }}\r\n                highlightFirstSuggestion={true}\r\n            />\r\n\r\n            <AutoSuggest\r\n                suggestions={suggestionsFilterValue}\r\n                onSuggestionsClearRequested={() => setSuggestionsFilterValue(suggestionsFilterValue)}\r\n                onSuggestionsFetchRequested={({ value }) => {\r\n                    setFilterValue(value);\r\n                    //setSuggestionsFilterValue(getSuggestionsFilterValue(value));\r\n                }}\r\n                onSuggestionSelected={(_, { suggestionValue }) =>\r\n                    console.log(\"Selected: \" + suggestionValue)\r\n                }\r\n                getSuggestionValue={suggestion => suggestion}\r\n                renderSuggestion={suggestion => <span>{suggestion}</span>}\r\n                inputProps={{\r\n                    placeholder: \"Type filter value\",\r\n                    value: filterValue,\r\n                    onChange: (_, { newValue, method }) => {\r\n                        setFilterValue(newValue);\r\n                    }\r\n                }}\r\n                highlightFirstSuggestion={true}\r\n            />\r\n\r\n            <button type=\"button\" onClick={removeTagFilteringComponent}>remove {props.eachKey}</button>\r\n            <p>tag: {props.eachKey} filter value: {props.eachValue}</p>\r\n        </section>\r\n\r\n        return display\r\n    }\r\n\r\nexport default TagFilteringComponent\r\n\r\n\r\n//slut","import React, {PropsWithChildren, useState} from \"react\";\r\nimport {FlashCardDeck} from \"../interfaces/flashcarddeck\";\r\nimport DisplayTagItem from \"./DisplayTagItem\";\r\nimport CardComponent from \"./CardComponent\";\r\nimport TagFilteringComponent from \"./TagFilteringComponent\";\r\nimport {SortingValueAll} from \"../interfaces/types/sortingValue\";\r\n\r\nconst TagFilteringComponentList: React.FC<{deckTagList: string[], content: Record<string, string>, setfunction: any }> =\r\n    (props) => {\r\n\r\n    const [show, setShow] = useState<boolean>(false)\r\n    const doSetShow = () => {\r\n        setShow(!show)\r\n    }\r\n\r\n    const contentList = (input: Record<string, string>): [number, string][] => {\r\n        const allKeys: number[] = Object.keys(input).map(each => parseInt(each)).sort()\r\n        var res: [number, string][] = [];\r\n        for (let i = 0; i < allKeys.length; i++) {\r\n            const eachKey: number = allKeys[i]\r\n            const eachVal: string = input[eachKey]\r\n            res.push([eachKey, eachVal])\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function addElement() {\r\n        const allKeys: number[] = Object.keys(props.content).map(each => parseInt(each)).sort()\r\n        var largestElement: number = 0;\r\n        for (let i = 0; i < allKeys.length; i++) {\r\n            const mynum: number = allKeys[i]\r\n            if (mynum > largestElement) {\r\n                largestElement = mynum\r\n            }\r\n        }\r\n        largestElement = largestElement + 1\r\n        var currentRecord: Record<string, string> = props.content\r\n        currentRecord[largestElement.toString()] = SortingValueAll[0]\r\n        props.setfunction(currentRecord)\r\n    }\r\n\r\n    const clear = () => {\r\n        var currentRecord: Record<string, string> = {}\r\n        props.setfunction(currentRecord)\r\n        doSetShow()\r\n    }\r\n\r\n    const showFitler = (): JSX.Element  => {\r\n        const displayIfShow: JSX.Element = <section>\r\n            <button type=\"button\" onClick={doSetShow}>showFilter</button>\r\n            <button type=\"button\" onClick={addElement}>addElement</button>\r\n            <button type=\"button\" onClick={clear}>clear</button>\r\n            <ul>\r\n                {contentList(props.content).map((item) => (\r\n                    <TagFilteringComponent deckTagList={props.deckTagList} content={props.content} setFunction={props.setfunction} eachKey={item[0]} eachValue={item[1]} />\r\n                ))}\r\n            </ul>\r\n        </section>\r\n\r\n        //show the first 3 strings\r\n        var stringValues: string[] = []\r\n        if (props.content['1']) {\r\n            stringValues.push(props.content['1'])\r\n        }\r\n        if (props.content['2']) {\r\n            stringValues.push(props.content['2'])\r\n        }\r\n        if (props.content['3']) {\r\n            stringValues.push(props.content['3'])\r\n        }\r\n        if (props.content['4']) {\r\n            stringValues.push('...')\r\n        }\r\n\r\n        const displayIfNotShow: JSX.Element = <section>\r\n            <p>{stringValues.toString()}</p>\r\n            <button type=\"button\" onClick={doSetShow}>showFilter</button>\r\n        </section>\r\n\r\n        if (show) {\r\n            return displayIfShow\r\n        }else {\r\n            return displayIfNotShow\r\n        }\r\n    }\r\n\r\n    const display: JSX.Element = <section>\r\n        {showFitler()}\r\n    </section>\r\n\r\n    return display\r\n\r\n}\r\n\r\nexport default TagFilteringComponentList\r\n\r\n\r\n//slut","import React, {useState} from \"react\";\r\nimport IPage from \"../interfaces/page\";\r\nimport {useDispatch, useSelector} from \"react-redux\";\r\nimport {cardDisplayActionCreator, State} from '../state/index';\r\nimport CardListComponent from \"../components/CardListComponent\"\r\nimport {FlashCard} from \"../interfaces/flashcard\";\r\nimport {bindActionCreators} from \"redux\";\r\nimport CardDisplay from \"../interfaces/cardDisplay\";\r\nimport DisplayTags from \"../components/DisplayTags\";\r\nimport TagFilteringComponentList from \"../components/TagFilteringComponentList\";\r\nimport {\r\n    calculateFilter, dogetSettings_filtercardsbytag,\r\n    filterByTags,\r\n    getSettings_filtercardsbytag\r\n} from \"../applogic/FlashcardDisplayLogic/FlashCardFiltering\";\r\n\r\nconst SearchFlashcards: React.FunctionComponent<IPage> = props => {\r\n\r\n    const MAXCARDSTODISPLAY: number = 100;\r\n\r\n    const characterSRSstate = useSelector(\r\n        (state: State) => state.characterSRS\r\n    )\r\n    const allTagKeys: string[] = Object.keys(characterSRSstate.tags)\r\n\r\n    function prepareNumberToDisplaySize(data: number): number{\r\n        return data > MAXCARDSTODISPLAY ? MAXCARDSTODISPLAY : data\r\n    }\r\n    const allCards: FlashCard[] = characterSRSstate.cards.sort(\r\n        function sortByCardNumbers(a: FlashCard, b: FlashCard){\r\n            if (a.cardNumber < b.cardNumber) {return -1; }\r\n            if (a.cardNumber > b.cardNumber) {return 1;}return 0;})\r\n\r\n    //tag filtering\r\n    const [localTagsFilter, setLocalTagsFilter] = useState<Record<string, string>>(dogetSettings_filtercardsbytag(characterSRSstate))\r\n    //const [localTagsFilter, setLocalTagsFilter] = useState<Record<string, string>>(setInitialLocalTagsFilter(localSettings))\r\n    const [shouldRerender, setShouldRerender] = useState<boolean>(false)\r\n    const [cardNumAfterFiltering, setCardNumAfterFiltering] = useState<FlashCard[]>([])\r\n\r\n    const doSetLocalTagsFilter = (input: Record<string, string>) => {\r\n        setLocalTagsFilter(input)\r\n        setShouldRerender(!shouldRerender)\r\n    }\r\n\r\n    const [displayChars, setDisplayChars] = useState<FlashCard[]>([])\r\n    const [maxCardsToDisplay, setMaxCardsToDisplay] = useState<number>(prepareNumberToDisplaySize(characterSRSstate.cards.length))\r\n    const [numberIntervalFilter, setNumberIntervalFilter] = useState(\"\")\r\n    const handleChangeNumberIntervalFilter = (e: React.FormEvent<HTMLInputElement>) => {setNumberIntervalFilter(e.currentTarget.value)}\r\n    const [tagSubstringFilter, setTagSubstringFilter] = useState(\"\")\r\n    const handleChangeTagSubstringFilter = (e: React.FormEvent<HTMLInputElement>) => {setTagSubstringFilter(e.currentTarget.value)}\r\n    const [fontSideSubstring, setFontSideSubstring] = useState(\"\")\r\n    const handleChangeFrontSideSubstringFilter = (e: React.FormEvent<HTMLInputElement>) => {setFontSideSubstring(e.currentTarget.value)}\r\n    const [backSideSubstring, setBackSideSubstring] = useState(\"\")\r\n    const handleChangeBackSideSubstringFilter = (e: React.FormEvent<HTMLInputElement>) => {setBackSideSubstring(e.currentTarget.value)}\r\n\r\n    const dispatch = useDispatch();\r\n\r\n    const {cardDisplayChangeState} = bindActionCreators(cardDisplayActionCreator, dispatch)\r\n    const showCardDisplay: CardDisplay = useSelector(\r\n        (state: State) => state.cardDisplay\r\n    )\r\n    var cardDisplayLocalState: CardDisplay = showCardDisplay\r\n    const changeShowPrimaryInformationValue = () => {\r\n        const currentValue: boolean = cardDisplayLocalState.showPrimaryCardInfo\r\n        const updatedValue: CardDisplay = {...cardDisplayLocalState, showPrimaryCardInfo: !currentValue}\r\n        cardDisplayChangeState(updatedValue, cardDisplayLocalState)\r\n    }\r\n    const changeShowSecondaryInformationValue = () => {\r\n        const currentValue: boolean = cardDisplayLocalState.showSecondaryCardInfo\r\n        const updatedValue: CardDisplay = {...cardDisplayLocalState, showSecondaryCardInfo: !currentValue}\r\n        cardDisplayChangeState(updatedValue, cardDisplayLocalState)\r\n    }\r\n\r\n    function sortbyIndexNumberAscendingInclUnknown() {\r\n        const sortedByNumber: FlashCard[] = allCards.sort(\r\n            function sortSmallToLarge(a: FlashCard, b: FlashCard){\r\n                if (a.cardNumber < b.cardNumber) {return -1; }\r\n                if (a.cardNumber > b.cardNumber) {return 1;}return 0;})\r\n        filterCards(sortedByNumber, localTagsFilter)\r\n    }\r\n\r\n    const filterCards = (inp: FlashCard[], localTagsFilter: Record<string, string>) => {\r\n        const inputListOfCards: FlashCard[] = filterByTags(inp, localTagsFilter)\r\n        setCardNumAfterFiltering(inputListOfCards)\r\n        if (numberIntervalFilter.length > 0) {\r\n            const result = displayByInterval(inputListOfCards)\r\n            setDisplayChars(result.slice(0,maxCardsToDisplay))\r\n        }else if (tagSubstringFilter.length > 0){\r\n            const result = displayByChosenTagTitleSubstring(inputListOfCards)\r\n            setDisplayChars(result.slice(0,maxCardsToDisplay))\r\n        }else if (fontSideSubstring){\r\n            const result = displayByFrontSideOfCard(inputListOfCards)\r\n            setDisplayChars(result.slice(0,maxCardsToDisplay))\r\n        }else if (backSideSubstring) {\r\n            const result = displayByBackSideOfCard(inputListOfCards)\r\n            setDisplayChars(result.slice(0,maxCardsToDisplay))\r\n        }else {\r\n            setDisplayChars(inputListOfCards.slice(0,maxCardsToDisplay))\r\n        }\r\n    }\r\n\r\n    function removeUnknown(input: FlashCard[]): FlashCard[] {\r\n        const onlyKnown: FlashCard[] = input.filter(x=>x.repetitionValue>0)\r\n        return onlyKnown\r\n    }\r\n\r\n    function sortbyIndexNumberAscending() {\r\n        const sortedByNumber: FlashCard[] = removeUnknown(allCards).sort(\r\n            function sortSmallToLarge(a: FlashCard, b: FlashCard){\r\n                if (a.cardNumber < b.cardNumber) {return -1; }\r\n                if (a.cardNumber > b.cardNumber) {return 1;}return 0;})\r\n        setDisplayChars(sortedByNumber.slice(0,maxCardsToDisplay))\r\n    }\r\n    function sortbyIndexNumberDescending() {\r\n        const sortedByNumber: FlashCard[] = removeUnknown(allCards).sort(\r\n            function sortToLargeToSmall(a: FlashCard, b: FlashCard){\r\n                if (a.cardNumber < b.cardNumber) {return 1; }\r\n                if (a.cardNumber > b.cardNumber) {return -1;}return 0;})\r\n        setDisplayChars(sortedByNumber.slice(0,maxCardsToDisplay))\r\n    }\r\n\r\n    function sortbyHistorySumDescending() {\r\n        const sortedByHistorySum: FlashCard[] = removeUnknown(allCards).sort((n1,n2) => getSumOfHistory(n1) - getSumOfHistory(n2));\r\n        setDisplayChars(sortedByHistorySum.slice(0,maxCardsToDisplay))\r\n    }\r\n\r\n    function getSumOfHistory(item: FlashCard): number {\r\n        const history: number[] = item.repetitionHistory\r\n        if (history === null ||\r\n            history === undefined ||\r\n            history.length == 0) {\r\n            return 0\r\n        }else {\r\n            try {\r\n                const result: number = history.reduce((sum,current) => sum + current, 0)\r\n                return result\r\n            }catch (e) {\r\n                return 0\r\n            }\r\n        }\r\n    }\r\n\r\n    function sortByReviewNumberAscending() {\r\n        const sortedByReviewValue: FlashCard[] = removeUnknown(allCards).sort(\r\n            function sortSmallToLarge(a: FlashCard, b: FlashCard){\r\n                if (a.repetitionValue < b.repetitionValue) {return -1; }\r\n                if (a.repetitionValue > b.repetitionValue) {return 1;}return 0;})\r\n        setDisplayChars(sortedByReviewValue.slice(0,maxCardsToDisplay))\r\n    }\r\n    function sortByReviewNumberDescending() {\r\n        const sortedByReviewValue: FlashCard[] = removeUnknown(allCards).sort(\r\n            function sortLargeToSmall(a: FlashCard, b: FlashCard){\r\n                if (a.repetitionValue < b.repetitionValue) {return 1; }\r\n                if (a.repetitionValue > b.repetitionValue) {return -1;}return 0;})\r\n        setDisplayChars(sortedByReviewValue.slice(0,maxCardsToDisplay))\r\n    }\r\n\r\n    function sortByLastReviewDateAscending() {\r\n        const sortedByLastReviewDate: FlashCard[] = removeUnknown(allCards).sort(\r\n            function sortSmallToLarge(a: FlashCard, b: FlashCard){\r\n                if (a.dateOfLastReview < b.dateOfLastReview) {return -1; }\r\n                if (a.dateOfLastReview > b.dateOfLastReview) {return 1;}return 0;})\r\n        setDisplayChars(sortedByLastReviewDate.slice(0,maxCardsToDisplay))\r\n    }\r\n    function sortByLastReviewDateDescending() {\r\n        const sortedByLastReviewDate: FlashCard[] = removeUnknown(allCards).sort(\r\n            function sortLargeToSmall(a: FlashCard, b: FlashCard){\r\n                if (a.dateOfLastReview < b.dateOfLastReview) {return 1; }\r\n                if (a.dateOfLastReview > b.dateOfLastReview) {return -1;}return 0;})\r\n        setDisplayChars(sortedByLastReviewDate.slice(0,maxCardsToDisplay))\r\n    }\r\n\r\n    function clearData() {\r\n        setDisplayChars([])\r\n    }\r\n\r\n    function toggleSize() {\r\n        if (maxCardsToDisplay < characterSRSstate.cards.length) {\r\n            setMaxCardsToDisplay(characterSRSstate.cards.length)\r\n        }else {\r\n            setMaxCardsToDisplay(MAXCARDSTODISPLAY)\r\n        }\r\n    }\r\n\r\n    const displayByFrontSideOfCard = (displayChars: FlashCard[]): FlashCard[] => {\r\n        const stringToLookFor: string = fontSideSubstring\r\n        const result: FlashCard[] = displayChars.filter((eachCard) => {\r\n            return eachCard.frontSide.includes(stringToLookFor)\r\n        })\r\n        return result\r\n    }\r\n\r\n    const displayByBackSideOfCard = (displayChars: FlashCard[]): FlashCard[] => {\r\n        const stringToLookFor: string = backSideSubstring\r\n        const result: FlashCard[] = displayChars.filter((eachCard) => {\r\n            return eachCard.backSide.includes(stringToLookFor)\r\n        })\r\n        return result\r\n    }\r\n\r\n    const displayByInterval = (displayChars: FlashCard[]): FlashCard[] => {\r\n        const stringToLookFor: string[] = numberIntervalFilter.split(\"-\")\r\n        if (stringToLookFor.length===2 && Number(stringToLookFor[0] && Number(stringToLookFor[1]))){\r\n            const result: FlashCard[] = displayChars.filter((eachCard) => {\r\n                return eachCard.cardNumber >= Number(stringToLookFor[0]) && eachCard.cardNumber <= Number(stringToLookFor[1])\r\n            })\r\n            return result\r\n        }else if (stringToLookFor.length === 1 && Number(stringToLookFor[0])) {\r\n            const result: FlashCard[] = displayChars.filter((eachCard) => {\r\n                return eachCard.cardNumber == Number(stringToLookFor[0])\r\n            })\r\n            return result\r\n        }\r\n        return displayChars\r\n    }\r\n\r\n    const displayByChosenTagTitleSubstring = (displayChars: FlashCard[]): FlashCard[] => {\r\n        const stringToLookFor: string = tagSubstringFilter//\"ball\"\r\n        const result: FlashCard[] = displayChars.filter((eachCard) => {\r\n            var substringIsFound: boolean[] = new Array()\r\n            for (let eachArrayKey in eachCard.tags) {\r\n                const eachTag: string = eachCard.tags[eachArrayKey]\r\n                if (eachTag.toString().toLowerCase().includes(stringToLookFor)) {\r\n                    substringIsFound.push(true)\r\n                }\r\n            }\r\n            return substringIsFound.length>0\r\n        })\r\n        return result\r\n    }\r\n\r\n    return <section>\r\n        <h1>Search current flashcard Deck</h1>\r\n        <p>number of cards: {characterSRSstate.cards.length} after filtering: {cardNumAfterFiltering.length} cards displayed: {displayChars.length}</p>\r\n        <button type=\"button\" onClick={toggleSize}>toggle size {maxCardsToDisplay}</button>\r\n        <button type=\"button\" onClick={clearData}>clear data</button>\r\n        <button type=\"button\" onClick={sortbyIndexNumberAscendingInclUnknown}>sortAllCardsByCharNumberAscending</button>\r\n        <button type=\"button\" onClick={changeShowPrimaryInformationValue}>showPrimary:{cardDisplayLocalState.showPrimaryCardInfo.toString()}</button>\r\n        <button type=\"button\" onClick={changeShowSecondaryInformationValue}>showSecondary:{cardDisplayLocalState.showSecondaryCardInfo.toString()}</button>\r\n        <p></p>\r\n        <button type=\"button\" onClick={sortbyIndexNumberAscending}>sortKnownCardsByCharNumberAscending</button>\r\n        <button type=\"button\" onClick={sortByReviewNumberAscending}>sortKnownCardsByReviewValueAscending</button>\r\n        <button type=\"button\" onClick={sortByLastReviewDateAscending}>sortKnownCardsByLastReviewDateAscending</button>\r\n        <p></p>\r\n        <button type=\"button\" onClick={sortbyHistorySumDescending}>sortKnownCardsByHistorySumDescending</button>\r\n        <button type=\"button\" onClick={sortbyIndexNumberDescending}>sortKnownCardsByCharNumberDescending</button>\r\n        <button type=\"button\" onClick={sortByReviewNumberDescending}>sortKnownCardsByReviewValueDescending</button>\r\n        <button type=\"button\" onClick={sortByLastReviewDateDescending}>sortKnownCardsByLastReviewDateDescending</button>\r\n        <p></p>\r\n        <TagFilteringComponentList deckTagList={allTagKeys} content={localTagsFilter} setfunction={doSetLocalTagsFilter}/>\r\n        <label htmlFor=\"interval\">interval:</label>\r\n        <input type=\"text\" id=\"interval\" name=\"interval\" value={numberIntervalFilter} onChange={handleChangeNumberIntervalFilter} />\r\n        <label htmlFor=\"fontside\">fontside:</label>\r\n        <input type=\"text\" id=\"fontside\" name=\"fontside\" value={fontSideSubstring} onChange={handleChangeFrontSideSubstringFilter} />\r\n        <label htmlFor=\"backside\">backside:</label>\r\n        <input type=\"text\" id=\"backside\" name=\"backside\" value={backSideSubstring} onChange={handleChangeBackSideSubstringFilter} />\r\n        <label htmlFor=\"tag\">tag:</label>\r\n        <input type=\"text\" id=\"tag\" name=\"tag\" value={tagSubstringFilter} onChange={handleChangeTagSubstringFilter} />\r\n        <CardListComponent data={displayChars} cardDisplay={cardDisplayLocalState}/>\r\n    </section>\r\n};\r\n\r\n\r\nexport default SearchFlashcards;","import IPage from \"../interfaces/page\";\r\n\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport {bindActionCreators} from \"redux\";\r\nimport { characterSRSactionCreators, State} from '../state/index';\r\nimport {FlashCard} from \"../interfaces/flashcard\";\r\nimport {FlashCardDeck} from \"../interfaces/flashcarddeck\";\r\nimport {editListItemInBulk} from \"../state/action-creators/characterSRSactionCreator\";\r\nimport {useState} from \"react\";\r\nimport {filterByTags, getSettings_filtercardsbytag} from \"../applogic/FlashcardDisplayLogic/FlashCardFiltering\";\r\n\r\nconst Statistics : React.FunctionComponent<IPage> = props => {\r\n    const dispatch = useDispatch();\r\n    const {editListItemInBulk} = bindActionCreators(characterSRSactionCreators, dispatch)\r\n    const characterSRSstate: FlashCardDeck = useSelector(\r\n        (state: State) => state.characterSRS\r\n    )\r\n    const [filteredCards, setFilteredCards] = useState<FlashCard[]>(getSettings_filtercardsbytag(characterSRSstate))\r\n\r\n    const countCardNumbers = (input: FlashCard[]): number[] => {\r\n        var result: number[] = []\r\n        const allNumbers: number[] = input.map(each => each.repetitionValue).sort()\r\n        const largestNum: number = allNumbers.reverse()[0]+1\r\n        for (let i = 0; i < largestNum; i++) {\r\n            const allOfThese: number = allNumbers.filter(eachNum => eachNum===i).length\r\n            result.push(allOfThese)\r\n        }\r\n        return result\r\n    }\r\n\r\n    const generateCountingDisplay = (input: FlashCard[], state: FlashCardDeck): string[] => {\r\n        var result: string[] = []\r\n        const countedNumbers: number[] = countCardNumbers(input)\r\n        const filteredCards: FlashCard[] = getSettings_filtercardsbytag(characterSRSstate)\r\n        const countFilteredCardNumbers: number[] = countCardNumbers(filteredCards)\r\n\r\n        //statistics display with no filtered cards\r\n        if (filteredCards && input && filteredCards.length == input.length) {\r\n            for (let i = 0; i < countedNumbers.length; i++) {\r\n                const currentLine: string = 'reviewNumber: ' + i + ' count: ' + countedNumbers[i]\r\n                result.push(currentLine)\r\n            }\r\n        }else {\r\n        //statistics display with filtered cards\r\n            for (let i = 0; i < countedNumbers.length; i++) {\r\n                var currentLine: string = 'reviewNumber: ' + i + ' count: ' + countedNumbers[i]\r\n                if (i < countFilteredCardNumbers.length) {\r\n                    currentLine = currentLine + ' ' + '('+ countFilteredCardNumbers[i] +')'\r\n                }\r\n                result.push(currentLine)\r\n            }\r\n        }\r\n        return result\r\n    }\r\n\r\n    const reviewNumbersCount: string[] = generateCountingDisplay(characterSRSstate.cards, characterSRSstate)\r\n\r\n    const newReviewNumbers = (oldReviewNumber: number, numberToAdd: number): number => {\r\n        if (numberToAdd > 0) {\r\n            if (oldReviewNumber === 0) {\r\n                return oldReviewNumber\r\n            }else if (oldReviewNumber > 0){\r\n                return oldReviewNumber+numberToAdd\r\n            }else {\r\n                return oldReviewNumber\r\n            }\r\n        }else if (numberToAdd < 0){\r\n            if (oldReviewNumber > 1) {\r\n                return oldReviewNumber+numberToAdd\r\n            }else {\r\n                return oldReviewNumber\r\n            }\r\n        }else {\r\n            return oldReviewNumber\r\n        }\r\n    }\r\n\r\n    function reducePositiveReviewNumbersByOne() {\r\n        const allFlashCards: FlashCard[] = characterSRSstate.cards\r\n        const reduceByOne: FlashCard[] = allFlashCards.map(eachCard => {\r\n            const eachRepetitionNumber: number = eachCard.repetitionValue\r\n            const newRepetitionNumber: number = newReviewNumbers(eachRepetitionNumber, -1)\r\n            var newCard: FlashCard = {...eachCard, repetitionValue: newRepetitionNumber}\r\n            return newCard\r\n        })\r\n        editListItemInBulk(reduceByOne, characterSRSstate)\r\n    }\r\n\r\n    function increasePositiveReviewNumbersByOne() {\r\n        const allFlashCards: FlashCard[] = characterSRSstate.cards\r\n        const reduceByOne: FlashCard[] = allFlashCards.map(eachCard => {\r\n            const eachRepetitionNumber: number = eachCard.repetitionValue\r\n            const newRepetitionNumber: number = newReviewNumbers(eachRepetitionNumber, 1)\r\n            var newCard: FlashCard = {...eachCard, repetitionValue: newRepetitionNumber}\r\n            return newCard\r\n        })\r\n        editListItemInBulk(reduceByOne, characterSRSstate)\r\n    }\r\n\r\n    function resetCardHistory() {\r\n        const allFlashCards: FlashCard[] = characterSRSstate.cards\r\n        const resetHistory: FlashCard[] = allFlashCards.map(eachCard => {\r\n            var newCard: FlashCard = {...eachCard, repetitionHistory: doResetHistory(eachCard.repetitionHistory)}\r\n            return newCard\r\n        })\r\n        editListItemInBulk(resetHistory, characterSRSstate)\r\n    }\r\n\r\n    function doResetHistory(repetitionHistory: number[]): number[] {\r\n        const newHistory: number[] = repetitionHistory.map(eachNumber => 1)\r\n        return newHistory;\r\n    }\r\n\r\n    function resetReviewDates() {\r\n        const allFlashCards: FlashCard[] = characterSRSstate.cards\r\n        const resetDates: FlashCard[] = allFlashCards.map(eachCard => {\r\n            var newCard: FlashCard = {...eachCard, dateOfLastReview: doResetDate(eachCard.dateOfLastReview)}\r\n            return newCard\r\n        })\r\n        editListItemInBulk(resetDates, characterSRSstate)\r\n    }\r\n\r\n    function doResetDate(dateOfLastReview: string) {\r\n        var today = new Date();\r\n        var yesterday = new Date();\r\n        yesterday.setDate(today.getDate() - 1);\r\n        const result = yesterday.toISOString().slice(0,10)\r\n        return result;\r\n    }\r\n\r\n    return <div>\r\n        <h1> The Statistics page </h1>\r\n        <p>number of cards: {characterSRSstate.cards.length} after filtering: {filteredCards.length}</p>\r\n        <button type=\"button\" onClick={increasePositiveReviewNumbersByOne}>increaseByOne</button>\r\n        <button type=\"button\" onClick={reducePositiveReviewNumbersByOne}>reduceByOne</button>\r\n        <button type=\"button\" onClick={resetCardHistory}>resetHistory</button>\r\n        <button type=\"button\" onClick={resetReviewDates}>resetReviewDates</button>\r\n        <ul>\r\n            {reviewNumbersCount.map(each => {\r\n                return <li>{each}</li>\r\n            })}\r\n        </ul>\r\n        </div>\r\n};\r\n\r\nexport default Statistics;","\r\nexport enum CardOrder {\r\n  CHRONOLOGICAL = 'chronological',\r\n  FREQUENCY = 'frequency'\r\n}\r\n\r\nexport enum InputTextType {\r\n  RAWTEXT = 'rawtext',\r\n  ORDEREDLINESTWO = 'orderedlinestwo',\r\n  ORDEREDLINESALL = 'orderedlinesall'\r\n}\r\n\r\nexport enum WritingSystem {\r\n    SIMPLIFIED = 'simplified',\r\n    TRADITIONAL = 'traditional',\r\n    GENERIC = 'generic'\r\n}","import {FlashCardDeck} from \"../../interfaces/flashcarddeck\";\r\nimport {FlashCard} from \"../../interfaces/flashcard\";\r\nimport {mapkeys} from \"../flashcardHelperFunctions/gettingFlashCards\";\r\n\r\n\r\nfunction updateDeckNumbers(newDeck: FlashCardDeck, numberOfCardsInOldDeck: number) {\r\n   var newCards: FlashCard[] = []\r\n   for (let i = 0; i < newDeck.cards.length; i++) {\r\n      const currentCard: FlashCard = newDeck.cards[i]\r\n      const currentCardNumber: number = currentCard.cardNumber\r\n      const updatedCard: FlashCard = {...currentCard, cardNumber: currentCardNumber + numberOfCardsInOldDeck}\r\n      newCards.push(updatedCard)\r\n   }\r\n   const updatedDeck: FlashCardDeck = {...newDeck, cards: newCards}\r\n   return updatedDeck;\r\n}\r\n\r\nfunction updateNotableCards(cardNumberUpdated: FlashCardDeck, numberOfCardsInOldDeck: number) {\r\n   var newCards: FlashCard[] = []\r\n   for (let i = 0; i < cardNumberUpdated.cards.length; i++) {\r\n      const currentCard: FlashCard = cardNumberUpdated.cards[i]\r\n      const notableCards: number[] = currentCard.notableCards\r\n      const updatedNotable: number[] = []\r\n      for (let k = 0; k < notableCards.length; k++) {\r\n         const oldNumber: number = notableCards[k]\r\n         const updatedNum: number = oldNumber + numberOfCardsInOldDeck\r\n         updatedNotable.push(updatedNum)\r\n      }\r\n      const updatedCard: FlashCard = {...currentCard, notableCards: updatedNotable}\r\n      newCards.push(updatedCard)\r\n   }\r\n   const updatedDeck: FlashCardDeck = {...cardNumberUpdated, cards: newCards}\r\n   return updatedDeck;\r\n}\r\n\r\nfunction updateTags(oldDeck: FlashCardDeck, notableCardsUpdated: FlashCardDeck): Record<string, string> {\r\n   const oldDeckTags: Record<string, string> = oldDeck.tags\r\n   const oldTagNames: string[] = mapkeys(oldDeckTags)\r\n   const newDeckTags: Record<string, string> = notableCardsUpdated.tags\r\n   const newTagNames: string[] = mapkeys(newDeckTags)\r\n\r\n   var allDeckNames = new Set<string>()\r\n   for (let i = 0; i < oldTagNames.length; i++) {\r\n      const name: string = oldTagNames[i]\r\n      allDeckNames.add(name)\r\n   }\r\n   for (let k = 0; k < newTagNames.length; k++) {\r\n      const name: string = newTagNames[k]\r\n      allDeckNames.add(name)\r\n   }\r\n   const allDeckNamesList: string[] = Array.from(allDeckNames.values()).sort()\r\n\r\n   var allDeckValuesList: string[] = []\r\n   for (let m = 0; m < allDeckNamesList.length; m++) {\r\n      const currentkey: string = allDeckNamesList[m]\r\n      const oldValue: string | null = oldDeckTags[currentkey]\r\n      const newValue: string | null = newDeckTags[currentkey]\r\n      var updatedValue: string = \"\"\r\n      if (oldValue != null) {\r\n         updatedValue = oldValue + \"\\n\"\r\n      }\r\n      if (newValue != null) {\r\n         updatedValue = updatedValue + newValue\r\n      }\r\n      allDeckValuesList.push(updatedValue)\r\n   }\r\n\r\n   var updatedDeck: Record<string, string> = {}\r\n   for (let o = 0; o < allDeckNamesList.length; o++) {\r\n      const key: string = allDeckNamesList[o]\r\n      const value: string = allDeckValuesList[o]\r\n      updatedDeck[key] = value\r\n   }\r\n   return updatedDeck\r\n}\r\n\r\nexport function mergeDecks(oldDeck: FlashCardDeck, newDeck: FlashCardDeck): FlashCardDeck {\r\n   const numberOfCardsInOldDeck: number = oldDeck.cards.length\r\n   //write code that update the deck number of the new deck, by incrementing them by the count of old cards\r\n   const cardNumberUpdated: FlashCardDeck = updateDeckNumbers(newDeck, numberOfCardsInOldDeck)\r\n\r\n   //write code that update the card references\r\n   const notableCardsUpdated: FlashCardDeck = updateNotableCards(cardNumberUpdated, numberOfCardsInOldDeck)\r\n\r\n   //write code that update the tags, so there are no overlaps\r\n   const updatedDeckTags: Record<string, string> = updateTags(oldDeck, notableCardsUpdated)\r\n   var updatedCards: FlashCard[] = oldDeck.cards\r\n   updatedCards = updatedCards.concat(notableCardsUpdated.cards)\r\n\r\n   const updatedWholeDeck: FlashCardDeck = {...oldDeck, cards: updatedCards, tags: updatedDeckTags}\r\n   return updatedWholeDeck\r\n}\r\n\r\n//***************  new merge deck ********************\r\n\r\n\r\nexport const getHashCode = (deck: FlashCardDeck): string => {\r\n   // Convert object to string\r\n   // You might want to select certain properties of the `FlashCardDeck` object if not all are needed\r\n   let str = JSON.stringify(deck);\r\n\r\n   let hash = 5381;\r\n   for (let i = 0; i < str.length; i++) {\r\n      let char = str.charCodeAt(i);\r\n      hash = ((hash << 5) + hash) + char; /* hash * 33 + c */\r\n   }\r\n   return hash.toString();\r\n}\r\n\r\n\r\n\r\n\r\nexport const getHashCodeCard = (deck: FlashCard): string => {\r\n   // Convert object to string\r\n   // You might want to select certain properties of the `FlashCardDeck` object if not all are needed\r\n   let str = JSON.stringify(deck);\r\n\r\n   let hash = 5381;\r\n   for (let i = 0; i < str.length; i++) {\r\n      let char = str.charCodeAt(i);\r\n      hash = ((hash << 5) + hash) + char; /* hash * 33 + c */\r\n   }\r\n   return hash.toString();\r\n}\r\n\r\n","import React, { useState } from 'react';\r\nimport { FilePond } from 'react-filepond';\r\nimport 'filepond/dist/filepond.min.css';\r\nimport {FlashCardDeck} from \"../interfaces/flashcarddeck\";\r\nimport {FlashCard} from \"../interfaces/flashcard\";\r\nimport {getHashCode} from \"../applogic/pageHelpers/mergeDeckHelper\";\r\n//import { FlashCardDeck } from './FlashCardDeck'; // Assume this is where you import from\r\n\r\ntype Props = {\r\n    handleContent: (decks: FlashCardDeck[]) => void,\r\n    // other props as needed\r\n};\r\n\r\nexport const FileInputMergeFiles: React.FC<Props> = ({ handleContent }) => {\r\n\r\n    //lav mappen om til: Map<number, [string, FlashCardDeck | null]>\r\n    const [flashCardDecks, setFlashCardDecks] =\r\n        useState<Map<string, [number, FlashCardDeck | null]>>(new Map());\r\n\r\n    const pond = React.useRef<any>(null);\r\n\r\n    function updateDeckState(deck: Map<string, [number, FlashCardDeck | null]>) {\r\n        setFlashCardDecks(deck);\r\n        const flatDeck = getArrayOfFlashCardDeck(deck);\r\n        handleContent(flatDeck);\r\n    }\r\n\r\n\r\n    const readAndParseFile = (file: any): Promise<FlashCardDeck | null> => {\r\n        return new Promise((resolve, reject) => {\r\n            const reader = new FileReader();\r\n            reader.onloadend = (event) => {\r\n                let data: FlashCardDeck | null = null;\r\n                if (event.target?.readyState == FileReader.DONE) {\r\n                    let strToParse: string | ArrayBuffer | null = event.target.result;\r\n                    try {\r\n                        if (strToParse != null) {\r\n                            data = JSON.parse(String(strToParse));\r\n                        }\r\n                    } catch (e) {\r\n                        console.error('Could not parse JSON from file');\r\n                    }\r\n                    resolve(data);  // Move this\r\n                }\r\n            };\r\n            reader.onerror = () => {\r\n                console.error('File could not be read');\r\n                reject();\r\n            };\r\n            reader.readAsText(file.file);\r\n        });\r\n    }\r\n\r\n    function getArrayOfFlashCardDeck(myMap: Map<string, [number, FlashCardDeck | null]>): FlashCardDeck[] {\r\n        // Transform map values into an array\r\n        let mapValues: [number, FlashCardDeck | null][] = Array.from(myMap.values());\r\n        let sortedArray: [number, FlashCardDeck | null][] =\r\n            mapValues.sort((a, b) => a[0] - b[0]);\r\n        // Filter out tuples where the second element is null\r\n        let filteredArray: FlashCardDeck[] = sortedArray\r\n            .filter((item): item is [number, FlashCardDeck] => item[1] !== null)\r\n            .map(item => item[1] as FlashCardDeck);\r\n        return filteredArray;\r\n    }\r\n\r\n    const handleProcessedFile = async (error: any, file: any) => {\r\n        //const data: FlashCardDeck | null = readAndParseFile(error, file);\r\n        const data: FlashCardDeck | null = await readAndParseFile(file);\r\n        if (data) {\r\n            let deck: Map<string, [number, FlashCardDeck | null]> = flashCardDecks;\r\n            let hashCodeOfDeck: string = getHashCode(data);\r\n            deck.set(hashCodeOfDeck, [flashCardDecks.size, data]);\r\n            updateDeckState(deck);\r\n        }\r\n    }\r\n\r\n    const handleRemoveFile = async (error: any, file: any) => {\r\n        //const data: FlashCardDeck | null = readAndParseFile(error, file);\r\n        const data: FlashCardDeck | null = await readAndParseFile(file);\r\n        if (data) {\r\n            let hashCodeOfDeck: string = getHashCode(data);\r\n            var deckToChange: Map<string, [number, FlashCardDeck | null]> = flashCardDecks;\r\n            if (deckToChange.has(hashCodeOfDeck)) {\r\n                let oldValue = deckToChange.get(hashCodeOfDeck);\r\n                if (!(oldValue) || oldValue[0] === undefined) {\r\n                    console.log(`Old value in deck has undefined index`);\r\n                } else {\r\n                    const oldIndexNumber: number = oldValue[0];\r\n                    // Set the new value for this key in the map\r\n                    deckToChange.set(hashCodeOfDeck, [oldIndexNumber, null]);\r\n                    updateDeckState(deckToChange);\r\n                }\r\n            } else {\r\n                console.log(`Deck named: ${data.deckName} is not found in the map.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    const removeAllFiles = () => {\r\n        // logic to remove all files\r\n        if (pond.current) {\r\n            const fileItems = pond.current.getFiles();\r\n            // Loop over the file items and remove each one\r\n            fileItems.forEach((fileItem: any) => {\r\n                pond.current.removeFile(fileItem.id);\r\n            });\r\n        }\r\n        const emptyMap: Map<string, [number, FlashCardDeck | null]> = new Map();\r\n        updateDeckState(emptyMap);\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            <button onClick={removeAllFiles}>Remove All Files</button>\r\n            <FilePond\r\n                ref={(ref) => (pond.current = ref)}\r\n                allowMultiple={true}\r\n                acceptedFileTypes={['application/json']} // If files are JSON\r\n                onaddfile={handleProcessedFile}\r\n                onremovefile={handleRemoveFile}\r\n                labelIdle='Drag & Drop your files or <span class=\"filepond--label-action\">Browse</span>'\r\n            />\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default FileInputMergeFiles;\r\n\r\n\r\n\r\n","import Practice from \"../pages/Practice\";\r\nimport Tags from \"../pages/Tags\";\r\nimport LoadAndSave from \"../pages/LoadAndSave\";\r\nimport EditDeck from \"../pages/EditDeck\";\r\nimport SearchFlashcards from \"../pages/SearchFlashcards\";\r\nimport Statistics from \"../pages/Statistics\";\r\nimport IRoute from \"../interfaces/route\";\r\nimport CreateDeck from \"../pages/CreateDeck\";\r\nimport Home from \"../pages/Home\";\r\nimport Settings from \"../pages/Settings\";\r\nimport MergeFiles from \"../pages/MergeFiles\";\r\n\r\nconst routes: IRoute[] = [\r\n    {\r\n        path: '/hanzimining',\r\n        name: 'Home',\r\n        component: Home,\r\n        exact: true\r\n    },\r\n    {\r\n        path: '/loadandsave',\r\n        name: 'LoadAndSave',\r\n        component: LoadAndSave,\r\n        exact: true\r\n    },\r\n    {\r\n        path: '/createDeck',\r\n        name: 'CreateDeck',\r\n        component: CreateDeck,\r\n        exact: true\r\n    },\r\n    {\r\n        path: '/mergefiles',\r\n        name: 'MergeFiles',\r\n        component: MergeFiles,\r\n        exact: true\r\n    },\r\n    {\r\n        path: '/editdeck',\r\n        name: 'EditDeck',\r\n        component: EditDeck,\r\n        exact: true\r\n    },\r\n    {\r\n        path: '/searchflashcards',\r\n        name: 'Search',\r\n        component: SearchFlashcards,\r\n        exact: true\r\n    },\r\n    {\r\n        path: '/practice',\r\n        name: 'Practice',\r\n        component: Practice,\r\n        exact: true\r\n    },\r\n    {\r\n        path: '/tags',\r\n        name: 'Tags',\r\n        component: Tags,\r\n        exact: true\r\n    },\r\n    {\r\n        path: '/statistics',\r\n        name: 'Statistics',\r\n        component: Statistics,\r\n        exact: true\r\n    },\r\n    {\r\n        path: '/settings',\r\n        name: 'Settings',\r\n        component: Settings,\r\n        exact: true\r\n    }\r\n]\r\nexport default routes;","import React, {useState} from \"react\";\r\nimport IPage from \"../interfaces/page\";\r\nimport {FlashCardDeck} from \"../interfaces/flashcarddeck\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport {bindActionCreators} from \"redux\";\r\nimport { characterSRSactionCreators, State } from '../state/index';\r\nimport {FileUploader} from \"../components/FileUploader\";\r\nimport {DragAndDropState} from \"../interfaces/dragAndDropState\";\r\nimport {FlashCard} from \"../interfaces/flashcard\";\r\nimport {mergeDecks} from \"../applogic/pageHelpers/mergeDeckHelper\";\r\n\r\nconst Home: React.FunctionComponent<IPage> = props => {\r\n\r\n\r\n    return <section>\r\n        <h1>Home</h1>\r\n        <p>... test 4</p>\r\n    </section>\r\n};\r\n\r\nexport default Home;","import React, {useState} from \"react\";\r\nimport IPage from \"../interfaces/page\";\r\nimport {FlashCardDeck} from \"../interfaces/flashcarddeck\";\r\nimport {generateAllLinesDeck,} from \"../applogic/pageHelpers/createDeckHelper\";\r\nimport {generateNewDeck} from \"../applogic/createDeck/createDeckMain\";\r\nimport {CreateDeckData} from \"../interfaces/createdeckdata\";\r\nimport {CardOrder, InputTextType, WritingSystem} from \"../interfaces/types/createDeckValues\";\r\n\r\n//skriv kode til at forbinde til endpoint /texttovocab, saa jeg kan downloade vocab fra raa text\r\n\r\nconst CreateDeck: React.FunctionComponent<IPage> = props => {\r\n    const downloadDeckUrl: string = \"https://chinesesentencemining-6z6zb.ondigitalocean.app/texttodeck\"\r\n    //const downloadDeckUrl: string = \"http://127.0.0.1:5000/texttodeck\"\r\n    const downloadVocabInfoUrl: string = \"https://chinesesentencemining-6z6zb.ondigitalocean.app/texttovocabinfo\"\r\n    //const downloadVocabInfoUrl: string = \"http://127.0.0.1:5000/texttovocabinfo\"\r\n    const downloadVocabRawUrl: string = \"https://chinesesentencemining-6z6zb.ondigitalocean.app/texttovocabraw\"\r\n    //const downloadVocabRawUrl: string = \"http://127.0.0.1:5000/texttovocabraw\"\r\n\r\n    const [selectsLanguage, setSelectsLanguage] = useState<WritingSystem>(WritingSystem.SIMPLIFIED)\r\n    const [sortorder, setsortorder] = useState<CardOrder>(CardOrder.CHRONOLOGICAL)\r\n    const [textType, setTextType] = useState<InputTextType>(InputTextType.RAWTEXT)\r\n    const [outputs, setOutputs] = useState<string>(\"\")\r\n\r\n    const download = (filename: string, text:string, isVocab: boolean, fileextension: string) => {\r\n        const element = document.createElement('a');\r\n        const dict = JSON.parse(text)\r\n        var res = \"\"\r\n        if (isVocab) {\r\n            res = dict[\"output\"]\r\n        }else {\r\n            res = text\r\n        }\r\n        const file = new Blob([res], {\r\n            type: \"text/plain;charset=utf-8\"\r\n        });\r\n        element.href = URL.createObjectURL(file);\r\n        element.download = filename + fileextension;\r\n        document.body.appendChild(element);\r\n        element.click();\r\n    }\r\n\r\n    //         console.log(\"save file code initiated\")\r\n    //         const element = document.createElement('a');\r\n    //         const file = new Blob([text], {\r\n    //             type: \"text/plain;charset=utf-8\",\r\n    //         });\r\n    //         element.href = URL.createObjectURL(file);\r\n    //         element.download = filename + \".txt\";\r\n    //         document.body.appendChild(element);\r\n    //         element.click();\r\n    //         console.log(\"save file code executed\")\r\n\r\n    const handleVocabWithInfo = () => {\r\n        handleVocab(downloadVocabInfoUrl)\r\n    }\r\n\r\n    //downloadVocabRawUrl\r\n    const handleVocabRaw = () => {\r\n        handleVocab(downloadVocabRawUrl)\r\n    }\r\n\r\n    const handleVocab = (endpint: string) => {\r\n        const deckName: string = ((document.getElementById(\"deckName\") as HTMLInputElement).value.trim());\r\n        const deckInfo: string = ((document.getElementById(\"deckInfo\") as HTMLInputElement).value.trim());\r\n        const vocab: string = ((document.getElementById(\"vocab\") as HTMLInputElement).value.trim());\r\n        const text: string = ((document.getElementById(\"text\") as HTMLInputElement).value.trim());\r\n        if (isEmptyString(deckName) || isEmptyString(deckInfo) || isEmptyString(text)) {\r\n            setOutputs(\"there is an error in in the input. make sure all fields are set\")\r\n        }\r\n        const bodyDict = {\r\n            \"deckName\": deckName,\r\n            \"deckInfo\": deckInfo,\r\n            \"script\": selectsLanguage,\r\n            \"cardOrder\": sortorder,\r\n            \"vocab\": vocab.split(/(\\s+)/),\r\n            \"textType\": textType,\r\n            \"sentencenames\": [],\r\n            \"text\": text.trim(),\r\n        }\r\n        const headers = new Headers();\r\n        headers.append('Content-type', 'application/json');\r\n        const options = {\r\n            method: 'POST',\r\n            headers,\r\n            body: JSON.stringify(bodyDict)\r\n        }\r\n        fetch(endpint, options)\r\n            .then(response => response.json())\r\n            .then(data => {\r\n                const res: string = JSON.stringify(data)\r\n                if (res != null) {\r\n                    setOutputs(\"no errors\")\r\n                    //setOutputs(res.toString())\r\n                }\r\n                download(deckName + \"_vocab\", res, true, \".json\")\r\n            })\r\n\r\n    }\r\n\r\n    const handleDownload = () => {\r\n        const deckName: string = ((document.getElementById(\"deckName\") as HTMLInputElement).value.trim());\r\n        const deckInfo: string = ((document.getElementById(\"deckInfo\") as HTMLInputElement).value.trim());\r\n        const vocab: string = ((document.getElementById(\"vocab\") as HTMLInputElement).value.trim());\r\n        const text: string = ((document.getElementById(\"text\") as HTMLInputElement).value.trim());\r\n        if (isEmptyString(deckName) || isEmptyString(deckInfo) || isEmptyString(text)) {\r\n            setOutputs(\"there is an error in in the input. make sure all fields are set\")\r\n        }\r\n        const bodyDict: CreateDeckData = {\r\n            \"deckName\": deckName,\r\n            \"deckInfo\": deckInfo,\r\n            \"script\": selectsLanguage,\r\n            \"cardOrder\": sortorder,\r\n            \"vocab\": vocab.split(/(\\s+)/),\r\n            \"textType\": textType,\r\n            \"sentencenames\": [],\r\n            \"text\": text.trim(),\r\n        }\r\n\r\n        if (selectsLanguage == WritingSystem.GENERIC && textType == InputTextType.ORDEREDLINESALL) {\r\n            setOutputs(\"cards generated entirely from text (deck name and info must still be set)\")\r\n            const resultOfCardGeneration: FlashCardDeck = generateAllLinesDeck(text.trim(), deckName, deckInfo)\r\n            const result: string = JSON.stringify(resultOfCardGeneration)\r\n            download(deckName, result, false, \".json\")\r\n        }else {\r\n            const headers = new Headers();\r\n            headers.append('Content-type', 'application/json');\r\n            const options = {\r\n                method: 'POST',\r\n                headers,\r\n                body: JSON.stringify(bodyDict)\r\n            }\r\n            const res: FlashCardDeck = generateNewDeck(bodyDict)\r\n            if (res != null) {\r\n                setOutputs(\"no errors\")\r\n                //setOutputs(res.toString())\r\n                download(deckName, JSON.stringify(res), false, \".json\")\r\n            }\r\n\r\n            /*\r\n            fetch(downloadDeckUrl, options)\r\n                .then(response => response.json())\r\n                .then(data => {\r\n                    const res: string = JSON.stringify(data)\r\n                    if (res != null) {\r\n                        setOutputs(\"no errors\")\r\n                        //setOutputs(res.toString())\r\n                    }\r\n                    download(deckName, res, false)\r\n                })\r\n                */\r\n        }\r\n    }\r\n\r\n    const isEmptyString = (data: string): boolean => typeof data === \"string\" && data.trim().length == 0;\r\n    return (\r\n\r\n        <section>\r\n            <button type=\"button\" onClick={() => handleDownload()}>text to deck</button>\r\n            <button type=\"button\" onClick={() => handleVocabWithInfo()}>text to vocab with info</button>\r\n            <button type=\"button\" onClick={() => handleVocabRaw()}>text to vocab raw</button>\r\n            <form>\r\n                <p>\r\n                    <label htmlFor=\"deckName\">deckName</label>\r\n                    <textarea id=\"deckName\" required rows={2}> </textarea>\r\n                </p>\r\n                <p>\r\n                    <label htmlFor=\"deckInfo\">deckInfo</label>\r\n                    <textarea id=\"deckInfo\" required rows={5}> </textarea>\r\n                </p>\r\n\r\n                <div>\r\n                    <p>Currently, only simplified characters are supported. Traditional characters will be supported at\r\n                        some point</p>\r\n                    <p>value: {selectsLanguage}</p>\r\n                    <select value={selectsLanguage} onChange={e => setSelectsLanguage(e.target.value as WritingSystem)}>\r\n                        <option value={WritingSystem.SIMPLIFIED}>simplified</option>\r\n                        <option value={WritingSystem.TRADITIONAL}>traditional</option>\r\n                        <option value={WritingSystem.GENERIC}>generic</option>\r\n                    </select>\r\n                </div>\r\n\r\n                <div>\r\n                    <p>choose the orderings frequency: </p>\r\n                    <p>value: {sortorder}</p>\r\n                    <select value={sortorder} onChange={e => setsortorder(e.target.value as CardOrder)}>\r\n                        <option value={CardOrder.CHRONOLOGICAL}>chronological</option>\r\n                        <option value={CardOrder.FREQUENCY}>frequency</option>\r\n                    </select>\r\n                </div>\r\n                <div>\r\n                    <p>choose the type of text you want to input: </p>\r\n                    <p>value: {textType}</p>\r\n                    <select value={textType} onChange={e => setTextType(e.target.value as InputTextType)}>\r\n                        <option value={InputTextType.RAWTEXT}>rawText</option>\r\n                        <option value={InputTextType.ORDEREDLINESTWO}>ordered2Line</option>\r\n                        <option value={InputTextType.ORDEREDLINESALL}>orderedAllLines</option>\r\n                    </select>\r\n                </div>\r\n                <div>\r\n                    <label htmlFor=\"vocab\">vocab</label>\r\n                    <textarea id=\"vocab\" required rows={2}> </textarea>\r\n                </div>\r\n                <div>\r\n                    <p>Insert the chinese text in the Text box. The data will be downloaded to a file</p>\r\n                    <label htmlFor=\"text\">Text</label>\r\n                    <textarea id=\"text\" required rows={10}> </textarea>\r\n                </div>\r\n                <div>\r\n                    <label htmlFor=\"output\">output</label>\r\n                    <p>value: {outputs}</p>\r\n                    <textarea value={outputs} required rows={2}> </textarea>\r\n                </div>\r\n            </form>\r\n            <br/>\r\n            <br/>\r\n            <br/>\r\n            <br/>\r\n            <br/>\r\n            <br/>\r\n            <br/>\r\n        </section>\r\n    )\r\n};\r\nexport default CreateDeck;\r\n\r\n","import characterSRSlogic from \"../../interfaces/characterSRSlogic\";\r\nimport {FlashCard} from \"../../interfaces/flashcard\";\r\nimport {getReviewPriority} from \"../characterSRSlogic/calculateCharacterSRSorder/calculateContentReviewPriority\";\r\nimport {FlashCardDeck} from \"../../interfaces/flashcarddeck\";\r\nimport {CreateDeckData} from \"../../interfaces/createdeckdata\";\r\n\r\n/*\r\nexport interface FlashCardDeck {\r\n    deckName: string;\r\n    deckInfo: string;\r\n    settings: Record<string, Record<string, string>>;\r\n    tags:  Record<string, string>;\r\n    cards: FlashCard[];\r\n}\r\n*/\r\n\r\nexport const generateNewDeck = (input: CreateDeckData): FlashCardDeck => {\r\n    const res: FlashCardDeck = {\r\n        deckName: \"deckname\",\r\n        deckInfo: \"deckinfo\",\r\n        settings: {},\r\n        tags: {},\r\n        cards: []\r\n    };\r\n    return res\r\n}\r\n\r\n","import React, {useState} from \"react\";\r\nimport IPage from \"../interfaces/page\";\r\nimport {FlashCardDeck} from \"../interfaces/flashcarddeck\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport {bindActionCreators} from \"redux\";\r\nimport { characterSRSactionCreators, State } from '../state/index';\r\nimport FileInputMainDeck from '../components/FileInputMainDeck';\r\nimport FileInputMergeFiles from \"../components/FileInputMergeFiles\";\r\n\r\n\r\nconst MergeFiles: React.FunctionComponent<IPage> = props => {\r\n    const dispatch = useDispatch();\r\n    const {createSRSobject} = bindActionCreators(characterSRSactionCreators, dispatch)\r\n    const characterSRSstate = useSelector(\r\n        (state: State) => state.characterSRS\r\n    )\r\n\r\n    const handleContent = (fileContent: string) => {\r\n        let testLarge: FlashCardDeck = JSON.parse(fileContent);\r\n        createSRSobject(testLarge);\r\n    }\r\n\r\n    const handleContent2 = (fileContent: FlashCardDeck[]) => {\r\n        console.log(\"Antal Decks: \" + fileContent.length)\r\n    }\r\n\r\n    return <section>\r\n        <h1>Merge deck files</h1>\r\n        <FileInputMergeFiles handleContent={handleContent2}/>\r\n\r\n    </section>\r\n};\r\n\r\nexport default MergeFiles;","import React, {useState} from \"react\";\r\nimport IPage from \"../interfaces/page\";\r\nimport {useDispatch, useSelector} from \"react-redux\";\r\nimport {cardDisplayActionCreator, characterSRSactionCreators, State} from '../state/index';\r\nimport CardListComponent from \"../components/CardListComponent\"\r\nimport {FlashCard} from \"../interfaces/flashcard\";\r\nimport {bindActionCreators} from \"redux\";\r\nimport CardDisplay from \"../interfaces/cardDisplay\";\r\nimport DisplayTags from \"../components/DisplayTags\";\r\nimport TagFilteringComponentList from \"../components/TagFilteringComponentList\";\r\nimport {calculateFilter} from \"../applogic/FlashcardDisplayLogic/FlashCardFiltering\";\r\nimport {stringify} from \"querystring\";\r\nimport {getSettings_filtercardsbytag} from \"../applogic/flashcardHelperFunctions/settingsHelper\";\r\n\r\nconst Settings: React.FunctionComponent<IPage> = props => {\r\n\r\n    const characterSRSstate = useSelector(\r\n        (state: State) => state.characterSRS\r\n    )\r\n\r\n    const dispatch = useDispatch();\r\n    const {replacesettings_filtercardsbytag} = bindActionCreators(characterSRSactionCreators, dispatch)\r\n    const [shouldRerender, setShouldRerender] = useState<boolean>(false)\r\n\r\n    const allTagKeys: string[] = Object.keys(characterSRSstate.tags)\r\n    const [localfiltercardsbytag, setLocalfiltercardsbytag] = useState<Record<string, string>>(getSettings_filtercardsbytag(characterSRSstate))\r\n    const doSetLocalfiltercardsbytag = (input: Record<string, string>) => {\r\n        setLocalfiltercardsbytag(input)\r\n        replacesettings_filtercardsbytag(input, characterSRSstate)\r\n        setShouldRerender(!shouldRerender)\r\n    }\r\n\r\n    return <section>\r\n        <h1>Settings</h1>\r\n        <p></p>\r\n        <TagFilteringComponentList deckTagList={allTagKeys} content={localfiltercardsbytag} setfunction={doSetLocalfiltercardsbytag}/>\r\n    </section>\r\n};\r\n\r\nexport default Settings;","import {FlashCardDeck} from \"../../interfaces/flashcarddeck\";\r\n\r\nexport const getSettings_filtercardsbytag = (currentState: FlashCardDeck): Record<string, string> => {\r\n    const subcategoryname: string = \"filtercardsbytag\"\r\n    const settings:  Record<string, Record<string, string>> = currentState.settings\r\n    var subcategory: Record<string, string> = {}\r\n    if (settings[subcategoryname]) {\r\n        subcategory = settings[subcategoryname]\r\n    }\r\n    return subcategory\r\n}\r\n\r\n","\r\nimport { NavLink } from 'react-router-dom';\r\nimport classes from \"./MainHeader.module.css\";\r\nimport routes from \"../config/routes\";\r\n\r\nconst MainHeader = () => {\r\n    return <header className={classes.header}>\r\n        <nav>\r\n            <ul>\r\n                {routes.map((route, index) => {\r\n                    return <li>\r\n                        <NavLink activeClassName={classes.active} to={route.path}>\r\n                            {route.name} </NavLink>\r\n                    </li>\r\n                })}\r\n            </ul>\r\n        </nav>\r\n    </header>\r\n};\r\n\r\nexport default MainHeader;","import React from 'react';\r\nimport './App.css';\r\nimport {Route, Switch, RouteComponentProps} from 'react-router-dom';\r\nimport routes from \"./config/routes\";\r\nimport MainHeader from \"./components/MainHeader\";\r\n\r\n\r\nconst App: React.FunctionComponent<{}> = props => {\r\n\r\n  return (\r\n    <div className=\"App\">\r\n        <MainHeader/>\r\n        <Switch>\r\n            {routes.map((route, index) => {\r\n                return (\r\n                    <Route\r\n                        key = {index}\r\n                        path = {route.path}\r\n                        exact={route.exact}\r\n                        render={(props: RouteComponentProps<any>) => (\r\n                            <route.component\r\n                                name = {route.name}\r\n                                {...props}\r\n                                {...route.props}\r\n                            />\r\n                        )}\r\n                    />\r\n                )})}\r\n        </Switch>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport { Provider } from \"react-redux\";\r\nimport { store } from \"./state/index\";\r\nimport {BrowserRouter} from \"react-router-dom\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider store={store}>\r\n        <BrowserRouter>\r\n            <App />\r\n        </BrowserRouter>\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}